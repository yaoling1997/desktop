题目大意是给出一个无向图
每个点要有一个非负的点权
一开始有k个点点有点权
每条边的点权we为它连接的两个点的点权的异或值
求使异或值之和最小的定点标号的方案
若有多种方案输出点权总和最小的那种
若有多种,任意输出一种
首先对于异或,每个二进制位互不相干
所以可以逐位考虑每个点的点权
那么假设现在考虑的是第p位
那么每个点的取值为0或1
对答案有贡献的边为一个点为0,一个点为1的边
很自然地想到最小割
把点集分为两个部分
新建s,t两个点
s向已知标号为0的点连容量+oo的边,表示该点属于s集合
已知标号为1的点向t连容量+oo的边,表示该点属于t集合
然后对于原图的边(u,v)
u向v和v向u分别连容量为1的边
然后跑最大流求出最小割即可
最小割的容量C就是这一位的最少的两端不同的个数
对答案的贡献是C*2^p
把每一位的贡献加起来就是总的最小的权值和
由于要输出方案
那么就从s开始dfs
不走满流的边
dfs到的点都是s中的点
一开始没注意题目要求
没有输出点权总和最小的那种方案
导致一直wa
为了在使边权和最小的情况下输出点权和最小的方案
可以令
s向已知标号为1的点连容量为+oo的边
已知标号为0的点向t连容量为+oo的边
因为从s开始dfs找最小割遇到满流边不走显然会使s中的点尽量少(因为满流边不都是割边)
对于与s和t不连通的那些点自动认为它们属于t集合
即他们第p位的值是0
然后就能ac了
