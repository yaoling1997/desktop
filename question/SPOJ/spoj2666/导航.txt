题意是
有一颗n个节点的树
一开始所有点是白色的
边上有权值(可以为负数)
有两种操作
第一种是翻转一个点的颜色(白变黑,黑边白)
第二种是询问树中两个白点之间的路径长度最大值
好久没敲过200多行的代码了
这种题目看了论文都要敲半天(3,4个小时的样子)
把树轻重链剖分后
对于每条重链
考虑与这样的所有路径
这里的所有路径指的是路径的深度最小的点
在这个重链上的路径
设D(i)为链上的第i个点
往下延伸到一个白点的最远距离
D2(i)为链上的第i个点
往下延伸到一个白点的次远距离
其中D2(i)对应的点和D(i)对应的点
不能属于i的同一个儿子的子树
所以每一个儿子弄一个最长的距离即可
没有的话赋值为-oo
对于链上的一个区间[L,R)
m= (L+R)/2
它在线段树上对应的节点为p
左右儿子为lc,rc
lc对应的区间为[L,m)
rc对应的区间为[m,R)
用MaxL,MaxR维护用来拼接的长度
MaxL[p]= max(MaxL[lc],dist(L,m)+MaxL[rc])
MaxR[p]= max(MaxR[rc],dist(R,m-1)+MaxR[lc])
设opt[p]为p这个区间所对应的最长链的长度
考虑最长链是否横跨两个区间可得
opt[p]= max(opt[lc],opt[rc],MaxR[lc]+dist(m-1,m)+MaxL[rc])
对于边界情况即L+1==R
若L是白点
MaxL[p]= MaxR[p]= max(0,D(L))
opt[p]= max(D(L),D(L)+D2(L))
若为黑点
MaxL[p]= MaxR[p]= D(L)
opt[p]= D(L)+D2(L)
考虑如何维护D(i),D2(i)
只需要每个节点开个堆即可
只考虑不与i在同一条重链的儿子j
把MaxL[j]+dist(i,j)丢到堆里即可
所以这里需要先让最小深度最大的重链先建起来
然后依次建即可
把每条重链的opt也丢到一个堆中
对于修改,要分别修改logn条重链上的某个点
每修改一条重链
设它深度最小的节点为o
就把新的MaxL[o]更新fa[o]的堆
然后再修改fa[o]的重链
修改后再把新的opt丢到存总的答案的堆中
修改的复杂度是logn^2的
查询是log的
x:
树链剖分
x1:
暴力