x:
UVa11990动态逆序对
大意是给一个长度为n的1~n的随机排列，每次删除一个值为x的数(不会重复删)，要求输出删除前的逆序对数(n<=200000,m<=100000）,m是操作数。
本机上3s可过，交上去就tle，没辙了。
我写的是树状数组套treap，一开始是动态开节点，每组数据都开一遍，导致常数大，超3s了，羔羊调了一下，一开始就把节点开了，勉强在2.8s以内
具体思想就是用树状数组(树状数组下标是位子的下标不是值)维护当前点往前的lowbit个点，把它的值存在treap中，查询的时候先查询前面有多少个比它小的，答案减去前面有多少个比它大的，再把后面的节点的treap的值删了，再在树状数组里从后往前查一遍，统计出一共有多少个比这个值小的点，相减一下就知道后面有多少个比它小的了。一开始的那个treap中有值相同的点，实际前面只有sum-1个比它小，当作小的处理，sum1统计出当前所有点中有多少个比它小，由于当前值在它位置的那个treap中已经被移除了，所以统计的是正确的，最后它后面就有sum1-(sum-1)个比它小的点，从ans里减去就行了
这样想应该更容易理解：
把treap看作是树状数组的点，树状数组只能从当前点向前查询，或向后修改，每次跳lowbit(o)个区间。这个点在o管辖的区间中，也肯定在o+lowbit(o)这个点的管辖的区间中，这个点管辖lowbit(o)个区间，所以查询时是o-=lowbit(o)跳到下一个管辖区间不重合的点，更新答案
x1:刘汝佳的
