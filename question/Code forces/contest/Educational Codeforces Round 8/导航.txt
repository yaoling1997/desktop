d:
好久没打数位dp了
然后搞了半天
最后发现答案出现了负数
结果是答案忘记+mo后再取模了
然后打完后才发现a和b的数位一样长
不知道有什么用
就是设状态为f[i][j][z]
z=0表示偶数位为d,奇数位不为d
z=1表示奇数位为d,偶数位不为d
f[i][j][z]
就表示最右边的那一位为第i位,模m的余数为j,模式为z的状态
转移就是根据要求枚举第i位上的数字,转移
f[i][(j*10+k)%m][z]= (f[i][(j*10+k)%m][z]+f[i-1][j][z])%mo
然后统计答案的时候
就把小于等于b和小于等于a-1的答案弄出来,设为B和A
枚举就是先把位数短的答案弄出来
弄位数最长的答案的时候就要从高位开始枚举数字
然后统计答案
最后的答案就是(B-A+mo)%mo
e:
预处理出每个'z'点往左和往右延伸得最远的连续的距离
然后枚举每条右上到左下的斜线
对于每条斜线,从右上枚举到左下,遇到z点就更新堆和树状数组
很显然,每次枚举下一个点时,已经枚举过的点至少需要往左的长度都会加一
所以对于每个点用位置编号与向左延伸的距离作为堆中的关键值
并在树状数组给该位置+1
把堆中关键值小于等于当前枚举的位置编号的点丢掉
并且把它在树状数组中对应的点-1
统计每个点的答案的时候
是把它看成z的最左下的那个点统计的
统计时就是看pos+1-right~pos之间有多少个点
