d:
一开始还写成了极角+长度判相等
其实只要用向量判相等即可
先求出代表所有线段的向量
比如说现在枚举到的两个点为u,v
把u,v看成二元组
令u<v
然后在让v-u
这样每种线段所对应的向量是唯一的
然后排序
设连续的一段有k个向量相等
代表有k条线段方向与长度相等
对ans有C(k,2)的贡献

e:
又是一道组合数问题
以前做过用到同样原理的题
题目大意是给出n,m
对于每个数组a
a长度为n
每个元素为1~m
求出每个不同的数组a的不同的子序列种类的和
子序列长度可以为0
每个数组a的不同子序列的不同种类和
对答案的贡献互不影响
我们考虑每个不同的子序列
被多少个长度为n的序列包含
对于长度为0的子序列可以单独算
那就是有多少个长度为n的序列
就有多少个长度为0的子序列
对于长度大于0的子序列
假设我们已经固定了这个子序列
x1x2...xk
要求有多少个长度为n的序列包含这个子序列
其中x_i到x_(i+1)之间不能有字符x_(i+1)
否则会算重
那就是枚举最后一个字符的位置j
那么前面还有j-1个位置放前k-1个字符
就有C(j-1,k-1)种
又因为x_i到x_(i+1)之间不能有字符x_(i+1)
所以每个不放固定字符的位置有m-1种放法
xk的位置的后面的空余位置每个有m种放法
进一步可以知道这k个字符无论长啥样
对答案的贡献都是 
n   
sigma C(j-1,k-1)*(m-1)^(j-k)*m^(n-j)
j=k 
所以这固定的k个字符每个有m种选择
所以第二部分的答案为
n    n   
sigmasigma C(j-1,k-1)*(m-1)^(j-k)*m^(n-j+k)
k=1  j=k 
令s=j-k
可进一步化为
n-1                  n-s 
sigma(m-1)^s*m^(n-s)*sigmaC(s+k-1,k-1)
s=0                  k=1
又因为
C(r,0)+C(r+1,1)+...+C(r+k,k)=C(r+k+1,k)
(利用C(m,n)=C(m-1,n-1)+C(m-1,n)证明)
所以
ans= m^n+
n-1                  
sigma(m-1)^s*m^(n-s)*C(n,n-s-1)
s=0                  

f:
凸包上二分的题目还是做得比较少
题目大意是给一个序列a
a中的元素可正可负
求一段连续的子序列[L,R]
   R  
使 sigma ai*(i-L+1) 最大
   i=L
首先求区间和的问题一般都可以先转化为前缀和的形式
令s[i]= a1+a2+...+ai
令p[i]= 1*a1+2*a2+...+i*ai
那么[L,R]的值就是p[R]-p[L-1]-(L-1)*(s[R]-s[L-1])
进一步化为-p[L-1]+(L-1)*s[L-1]+p[R]-(L-1)*s[R]
令
xi=i
yi=-p[i]+(i)*s[i]
然后可以试着固定左端点找右端点或固定右端点找左端点
这里固定右端点R
再来找左端点
对于两个左端点i+1<j+1
[j+1,R]-[i+1,R]= yj-yi-s[R](xj-xi)

j比i不差等价于
[j+1,R]-[i+1,R]>=0
等价于s[R]<=(yj-yi)/(xj-xi)
j比i不优等价于
[j+1,R]-[i+1,R]<=0
等价于s[R]>=(yj-yi)/(xj-xi)

把(xi,yi)看成点
所有点的x坐标都不相同
构造一个上凸包
显然不在凸包上的点不可能成为决策点
因为不在凸包上的点不可能是最左或最右的点
所以凸包上一定有x小于它的点和x大于它的点
设它(p点)与它左边相邻的点p1,p2的斜率为k1,右边相邻的点斜率为k2
若s[R]<=k2 则p2不比p差
若s[R]>k2 有因为k2>k1所以p不比p1优
所以决策点为上凸包的点
又因为对于凸包上的点i和i-1
设它们的斜率为k
若s[R]<=k则i不比i-1差
又因为j<=i-1 j与i的斜率k'>=k所以i不比j差
若s[R]>k则i不比i-1优
又因为j>=i i-1与j的斜率k'<=k所以j不比i-1优
所以就可以在凸包上二分了
所以固定右端点,查询左端点时在凸包上二分
并维护凸包即可