c:
很有意思的一道题
题目大意就是给一个n*m的方格(n<=1000,m<=1000)
有的格子标'1','2','3','.','#'
保证1,2,3分别联通(4联通)
'#'是障碍物,'.'可以修路
要求修最少的点使1,2,3全部联通
就是bfs,看每个'.'到块1,块2,块3的最短距离
然后ans= min(f[1][i][j]+f[2][i][j]+f[3][i][j]-2)就行了
这是3个块互不联通的情况
三个块互不联通还有一种特殊情况就是其中一个块成为中介(具体参见数据)
这种情况枚举每个块特殊判断即可
2个块不联通类似
1个块...

d:
好久没写dp了,看了题解,写了半天才过
当s>n*(n-1)/2时显然是选k个最小的(冒泡排序最坏情况)
否则设所选的k个数的原来的下标分别为i1,i2...ik
注意到i1<i2....<ik,因为交在前k个元素中交换不会使答案更优,反而会消耗次数
所以花费的次数T=i1-1+i2-2+...+ik-k=i1+i2+...+ik-k*(k+1)/2
T<=s
即i1+i2+...+ik<=s+k*(k+1)/2
令M= s+k*(k+1)/2
即选出来的k个数字的原来的下标之和<=s+k*(k+1)/2
然后就可以dp了
设f[i][j][p]表示前i个数中选j个,这j个数字的下标和为p
f[i][j][p]= min(f[i-1][j][p],f[i-1][j-1][p-i]+q[i])

