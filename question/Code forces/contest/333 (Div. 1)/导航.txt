d:
连数据结构都不会写了
就是边dfs边建trie树
譬如说要建节点v的trie
可以从v开始dfs
每进入一个儿子
就看trie的当前节点是否有对应字母的儿子
有就让标记变量进去
没有就新建一个儿子再进去
这样对于一个节点我们顶多话O(n)的时间建trie树
trie的节点个数就是答案
但是要把每个节点的trie树都弄出来
我们只需在搞v的trie时利用它的子树节点数最多的儿子的trie
其它儿子的按之前的方法暴力搞就行
为何?
因为这样做
每个节点顶多暴力扫log次
因为其余儿子为根的子树u的总点数size[u]<=size[v]/2
每执行一次
size[u]所在的集合的总点数至少会变成2*size[u]
因为已经把那些子树都合并了
所以是log的
为了不mle
还要用左儿子右兄弟的方法建树
当然,用vector更加无脑
不过为了练习指针还是用了左儿子右兄弟
然后农了半天
打错了变量名
head[o]表示跳到o的第一个儿子
next[i]连接的都是兄弟
即连接的都是o的儿子
ch[i]表示i这个地址由什么样的字符指过去
c[]是用来搞笑的

e:
浪哥推荐题
咋一看是数据结构
再一看是dp
反正想了半天想不到点上就去看题解了
题解看了半天
发现是分治+dp
这道题是离线做的
先考虑几个特例来打开思路
若没有删除操作
那么直接扫到物品就拿去更新f[]
扫到回答就输出
若只有删除操作
那么倒过来做即可
然后再来考虑怎样真正地解决这道题
正解是分治+dp
看看这个来自题解的图
图1
我们来分治
先求出s1交s2交s3.....交sn的物品
来初始化dp数组f[]
然后把它们对半分开,分别递归到两个部分
然后每个部分可以在父亲的信息基础上更新
更新就是再把sl交s2...交smid中没有在父亲的交中出现的物品拿去更新当前的状态
一直分治直到当前没有或只有一个元素
顶多分治log层
发现每个物品影响的询问区间都是一段
有点像线段树的区间查询
然后就是一些细节问题
譬如说对于同一层
要把操作时间小于当前L的操作应用了
有的细节还是要打的时候才能想清楚
那个输出格式是卖萌的
