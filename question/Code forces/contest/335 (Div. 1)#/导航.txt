这是我打得最糟糕的一次cf,没有之一
a:
那么显然的贪心都没看出来。。。
就是找到最长连续上升子序列
设长度为m
最小代价为n-m
找的话就从左到右扫f[a[i]]= f[a[i]-1]+1就行

b:
一句话放错位置
有全为树边的数据
然后就跪了

c:
好神奇的做法
以a,b分别为轴建立直角坐标系
(p,q)为坐标上的一个点P
把project看成向量vi
问题就变成了使
Q=O+sigmaxi*vi
Q.x>=P.x,Q.y>=P.y
但是注意到当exp达到p的时候,dollar可能>q
大于q的这部分钱可以不要,并不影响最后的答案
于是我们新引进两个点pn+1,pn+2
pn+1=(0,max(pi.y))
pn+2=(max(pi.x),0)
再连接OP
直线OP与当前点的凸包会有交点K1,K2
不妨设K2.x>=K1.x,K2.y>=K1.y
那么OK2就是我们要的向量
P.y/OK2.y==P.x/OK2.x
答案为P.y/OK2.y
当然可以把原点也放进凸包,那么就只用考虑一个交点了
把图画出来,显然其它的点都没有这个优

d:
表示看了题解和标程半天才反应过来这题是树套树
QAQ......
发现可以用树状数组套multiset
建系
将每个卡片a,b,c,d
看成是(a,b)到(c,d)的向量
一开始起点为(0,0)
然后开始bfs
设当前位置为(x,y)
则把所有卡片中a<=x,b<=y的目标点(c,d)加入队列Q
直到第n张卡片的起始点在当前位置和原点形成的矩形中
然后我们要来用数据结构优化......
显然可以把坐标离散化
但其实只需要离散x
把x离散后
就可以开始树套树了
树状数组维护x轴
multiset维护y轴
把那些所谓的向量放进树中
树状数组维护每个向量的起点的x
multiset维护每个向量起点的y
每次从队列中取出当前点now(x,y)时
就把所有起点在O和now形成的矩形中的向量的目标点放进队列中
具体来说就是每跳到树状数组的一个节点(-=lowbit)
就把这个multiset中的y<=now.y的向量处理掉
不过注意为了使每个向量只进入队列一次
必须在放的时候将它从树套树中移出
不过每个向量出现了log次
所以搞个数组b记录一下表示它是否被移除
以便下次再遇到它时不让它入队列
这样比从它插入的那个位置开始删除会好一点
搞个p[]记录一下每个向量是从哪个向量到达的
然后就没了

e:
概率和期望学得太渣了
看了题解和标程想了半天都没想出来
关键是题解和标程不一致......
最后终于想明白了题解是在说什么
并且用无穷等比数列求和推出了
初值要赋值为1/p[i][n]/100.
加.表示double类型的数字
然后感觉题解在更新的那部分有点问题
然后就投靠了标程
然后发现了这么个东西
设当前点j可以到的点从好到坏一次为v[0]~v[k]
一个点越好表示该点到n点的期望长度越小
v[0]就是n了
那么答案就是
令P[i][j]=p[i][j]/100.
(ans[v[0]]*P[j][v[0]]
+ans[v[1]]*(1-P[j][v[0]])*P[j][v[1]]
+ans[v[2]]*(1-P[j][v[0]])*(1-P[j][v[1]])*P[j][v[2]]
+...
+ans[v[k]]*(1-P[j][v[0]])*...*(1-P[j][v[k-1]])*P[j][v[k]])
/(P[j][v[0]]*p[j][v[1]]*...*p[j][v[k]])
不知道为啥是这个
然后dijkstra每次更新就是了
先确定的点的期望长度肯定最小
然后就没了


