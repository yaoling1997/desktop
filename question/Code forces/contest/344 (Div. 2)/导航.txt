c:
好久没敲splay了
于是心血来潮敲了个splay
然后发现好多地方都敲错了
改了半天
然后发现print的时候又忘记下放标记了
用splay就是先读那些玩意
如果后面读进来的r>=前面的r那么就把前面的去掉直到不能去为止
如果小于前面的r但改变的顺序是一样的
就不需要考虑
最后需要执行的操作肯定是从长到短交替着弄
很显然可以对于第一个长的操作进行排序
之后的就翻转就行
然后就想到了splay
不过别人的代码都挺短的,正解应该不是splay

正解的方法很巧秒(是我太傻了)
前面处理询问是一样的
然后把a数组复制一份给b数组
然后让b+1~b+r1不减排序
弄两个指针p=1,q=r1
然后从第2个处理开始往后面扫
设当前扫到第i个处理
那么ri+1~r_(i-1)的值都可以确定了
依照t_(i-1)确定
然后就没了

d:
一道字符串hash水题
结果还是跪了几发......
第一次是数组开小了,只开了300
数组开小竟然返回wa
第二次是答案没开long long
第三次是数组没开long long
首先把相邻的字符相同的合并掉
然后特判s长度为1的情况
其它情况就是除了s的第一个块和最后一个块外
中间那一节hash判断相等
我开了两个hash
一个是数字的hash(每个字符长度的hash)
一个是字符串的hash
然后就没了

e:
模型转换真神奇
标签上写的是数据结构和dp
但题解给的是二分
一开始都懒得划式子了
看了题解后才知道划式子的重要性
假设把一个元素插到它的右边
那么右边有一整块的元素要向左移动(设这种情况为left)
我们设与答案的差值为Δl,r
Δl,r = (al·r + al + 1·l + ... + ar·(r - 1)) - (al·l + al + 1·(l + 1) + ... + ar·r) = al·(r - l) - (al + 1 + al + 2 + ... + ar)
假设把右边一个元素向左移动(设这种情况为right)
那么
与一开始的答案的差值为Δ'l,r
Δ'l,r = (al·(l + 1) + al + 1·(l + 2) + ... + ar·l) + (al·l + al + 1·(l + 1) + ... + ar·r) = (al + al + 1 + ... + ar - 1) + ar·(l - r)
设si为1~i的a数组的前缀和
那么
Δl,r= (r*a_l - s_r)+(s_l-l*a_l)
Δ'l,r= (l*a_r - s_(l-1))+(s_(r-1)-r*a_r)
那么对于left的情况,只要固定了l,那么就只需要查询r了
因为每个确定的l,差值只跟r有关
对于right的情况,只要固定了r,那么就只需要查询l了
因为每个确定的r,差值只跟l有关
看差值的前面那个括号里的玩意
设y= (r*a_l - s_r)
是不是很像一条二维坐标里的直线
那right情况来说
从左到右扫r
每次都把这样一条直线加入用来维护的数组里面
相当于维护一个下凸包
因为斜率是递增的
所以对于查询就只要看凸包上的点的x值
然后在凸包上二分一下即可
对于left的情况也是类似的做法
