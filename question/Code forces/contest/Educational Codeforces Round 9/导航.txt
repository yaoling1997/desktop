c:
好神奇的一道题
对于两个串a,b
按a+b<b+a排序
最后把排序后的结果输出来
证明a+b<b+a满足传递性
把a,b看成26进制数字
<=>a*26^|b|+b<b*26^|a|+a
<=>a*26^|b|-a<b*26^|a|-b
<=>a/(26^|a|-1)<b/(26^|b|-1)
所以若有a+b<b+a,b+c<c+b
则必有a+c<c+a
所以传递性得证
然后证明正确性
若相邻两个串a+b<b+a
那么a肯定要在b的前面
否则答案的字典序显然更大

d:
又是一个调和级数复杂度的题目......
还是看了题解才会
一开始想的直接枚举最小公倍数,结果是n*nlog的
其实没必要枚举最小公倍数
首先忽略大于m的元素
然后相同的元素的个数都存到map里面
然后从小到大1~m枚举数字
设当前枚举的数字的个数为cnt
让它的<=m的倍数的答案都加上cnt
最后枚举1~m统计答案即可
统计答案就是看枚举的i能被多少个元素整除
相同的取最小的那个
否则选取的i可能不是最小的公倍数
复杂度是mlnm的

e:
虽然一眼就直到是fft再套个快速幂
但是一开始就t在第5个点
然后改了半天
过不了
看了题解
发现确实是这样做的
虽然还有别的做法
然后还是一直t
然后看了别人的fft的程序
然后改了一下
甚至抛弃vector改成数组形式的了
还是t
然后造数据
发现大数据跑出来的答案和别人的不一样
然后发现fft几次精度特别萎
然后不得不每次fft后都给每个数字取整
然后还要跟1取min
最后答案没有问题了
然后还是t
最后在ksm里加了个特判
当k==0时不执行a=a*a
然后就过了......
