d:
又是一个调和级数复杂度的题目......
还是看了题解才会
一开始想的直接枚举最小公倍数,结果是n*nlog的
其实没必要枚举最小公倍数
首先忽略大于m的元素
然后相同的元素的个数都存到map里面
然后从小到大1~m枚举数字
设当前枚举的数字的个数为cnt
让它的<=m的倍数的答案都加上cnt
最后枚举1~m统计答案即可
统计答案就是看枚举的i能被多少个元素整除
相同的取最小的那个
否则选取的i可能不是最小的公倍数
