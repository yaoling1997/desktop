#表示补交的题目
2个半小时7道题,都很水
结果还没有写完,只写了5道(码力不行)
做完a,b竟然已经过去半个小时了...
a:
一开始还看错题了
以为她一直走可以走到多少个不同的地方
结果是她走一次停在哪个地方
少打了个'='wa了一发

b:
直接弄个堆再套个string即可
文字比较多看了半天

c:
从小到大枚举玩具,能买就买,遇到不同的不买
每个不同的玩具对答案贡献都是1,肯定从价值少的开始选
枚举次数k,是根号m级别的(1+2+3+...k=(1+k)*k/2)

d:
从最下面最左端开始,而且一开始是往上的
发现每三个点判断一下叉积即可

e:
一开始想复杂就直接敲了(老毛病又犯了)
敲到后面发现太麻烦
仔细想想发现对于一个连通块
如果有环的话所有的点都可以不是孤立点
环中的点配环中的边,环外面的边分给那些不在环内的点
设联通块点数为n,边数为m
由于联通m>=n-1
若m>n-1,又由于没有自环和重边
所以肯定有那种环内的点不止一个的那种环
所以对答案有贡献当且仅当某个连通块内的边数>=点数
且贡献为1(一棵树,随便选一个点当根,其它的边都分给后代了)

#f:
到最后只有20分钟了
而且题目也不短
敲完了也有一堆的错误...
n*m个干草堆在一个n*m的棋盘里
设每个干草堆的高度为a[i][j]
保证了一开始a[i][j]>=1
给了一个k
可以从任意的干草堆中去掉任意高度的干草
若一个干草堆里干草为0
那么那个位置就没有干草堆了
要求最后的状态满足以下条件
1:剩下的干草堆中干草总高度为k
2:每个有干草的堆,它们拥有的干草的高度要相同
3:至少有一个干草堆的干草高度和它一开始的高度相同
4:所有干草堆要4联通
乍一看题目限制超多,有点棘手
经过短暂的思索
以第3个条件为突破口
把所有干草堆按高度从小到大排序
再从大到小枚举
假设当前枚举到了第i个干草堆
假设这个干草堆的干草是最小的
显然答案包含在某个干草堆是最小的情况中
即这个干草堆的高度到最终状态都不变
也就是其它的干草堆的高度要跟它一样
同时不断维护各个连通块的大小
每次多了一个干草堆
就有可能使与它相邻的连通块合并
设当前枚举的干草堆的高度为z
当最大联通块的个数*z>=k
并且(总的草高度-k)%z=0
即k%z=0
就有解了
从当前枚举的干草堆的位置bfs
得到一个大小为k/z的连通块即可

#f
模拟比赛时没时间看这道题
补的时候发现题目的标签是dp+组合数
然后一直在想怎么线性dp
然后没想出来
看了题解才发现
根本不是我想的那种dp
是更加广义上的dp...(找递推关系式)
就是要划式子
然后找递推关系
组合数也不是那种从n中取m个的那种
大概做法就是设f(l,r)表示l到r每块木板都要取一部分的方案数
l=r分开算
就是h[r]-1种(windows下l和1分不清楚)
若l<r
h[l]的能够变化的方案数是min(h[l],h[l+1])-1
因为要和h[l+1]接起来
所以如果h[l]>h[l+1]
高出来的那一部分肯定要取
取的范围是h[l]-h[l+1]+1到h[l]-1
不能全部取完(题目规定)
那么方案数就是h[l+1]-1
若h[l]<=h[l+1]
那就是h[l]-1了
所以综上所述就是min(h[l],h[l+1]-1)
同理r的能取的方案数是min(h[r-1],h[r])-1
对于l<i<r
能取的方案数是min(h[i-1],h[i],h[i+1])-1
然后肯定是可以拼起来的
所以f(l,r)=
min(h[l]-1,h[l+1]-1)*min(h[r-1]-1,h[r]-1)
 r-1 
*∏min(h[i-1]-1,h[i]-1,h[i+1]-1)
 i=l+1
然后
     n        n-1   n                                       r-1  
ans=Σ hi -1 + Σ  Σ min(hl -1,hl+1 -1)*min(hr -1,hr-1 -1)*∏min(h[i-1]-1,h[i]-1,h[i+1]-1)
    i=1        l=1  r=l+1                                   i=l+1

     n        n-1                     n                     r-1  
ans=Σ hi -1 + Σ  min(hl -1,hl+1 -1)*Σ min(hr -1,hr-1 -1)*∏min(h[i-1]-1,h[i]-1,h[i+1]-1)
    i=1        l=1                   r=l+1                  i=l+1

       n                     r-1
令s(l)=Σ min(hr -1,hr-1 -1)*∏min(h[i-1]-1,h[i]-1,h[i+1]-1)
      r=l+1                  i=l+1
         n                     r-1
则s(l+1)=Σ min(hr -1,hr-1 -1)*∏min(h[i-1]-1,h[i]-1,h[i+1]-1)
        r=l+2                  i=l+2

最后可以划成

s(l)= min(hl -1,hl+1 -1,hl+2 -1)*s(l+1)+min(hl+1 -1,hl -1)
倒着把s(i)全推出来
再算答案即可
总复杂度O(n)
