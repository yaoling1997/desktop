d:
表示正解dp看了题解和源代码想了半天都没想出来
大概是从一般求lcs来考虑
已知f[n][n]= n-1
f[x][y]表示S串前x个,T串前y个的最长公共子序列
显然我们只要考虑abs(x-y)<=1的状态
然后巴拉巴拉
反正没搞出来
然后发现还有一种贪心做法
就是我们把S中的一个字符删去,然后在某个位置上放上一个字符
考虑哪些是非法的,哪些是会算重复的
将一个子串分成几部分,把字符相同的且连续的尽可能长的每一段分为一组
一共分成了k组
譬如说
aabbbca
分成
[aa][bbb][c][a]
1    2    3  4
然后对于每一组
无论删掉哪一个
再随便插入其它字符都是一样的
就拿第一组来说
删掉第一个a再随便插和删掉第二个a再随便插是一样的
所以对于每一组只需考虑删一次的情况
设我们选的第i组的大小是g,字符为c
那么插c字符时插到与i组中的任何元素相邻的位置都是不行的,总共有g个这样的位置
再考虑第j组(i!=j)大小为h,字符为d
那么插字符d时又会多算h次
所以每一个组对答案的贡献就是n*m-n
除此之外还有别的把答案算重的情况(QAQ)
譬如说ababa变成babab就有两种变法(显然看得出来)
对于这个串的其中一截bab
把它变成aba也有两种变法
所以可以发现答案还得减去所有长度>=2的那样的串的个数
可以发现没有别的情况了(论感性的重要性)
