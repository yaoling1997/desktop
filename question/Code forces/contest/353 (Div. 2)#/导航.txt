感觉打得很崩
不过还是进前两百了
所以codeforce上手速还是很重要的
虽然我手速并不快
最遗憾的是c题到最后都没做出来

d:
每个元素记录一下它的插入时间
然后从小到大排序
然后每次选当前区间时间最小的那个点为根节点
把区间划分为两段
递归建树
还开了个线段树维护区间最小值
其实用RMQ就行了
不过RMQ打得比较少
而且还害怕取log时会有什么意想不到的错误
其实只要+个eps向下取整即可

#c:
题意就是有n个点排成一个圈
每个点有个权值
保证总权值为0
每个点可以把一部分的权值移给相邻的点
问最少操作多少次使得每个点的权值为0
问题等价于在环上选若干区间
使得每个区间的和为0
这种选法的答案为n-总区间数
因为对于某个区间
假设它长度为L
那么它对答案的贡献为L-1
也可以视为一开始都是长度为1的区间
即一开始有n个区间
然后要合并一些区间
使得每个区间的区间和为0
每次合并相邻的区间,总的区间数-1,代价+1
所以显然代价=n-剩下的区间数
现在就是要使得剩下的区间数尽量多
假设最终的状态是由一些区间组成
并且最多只有一个区间有某段前缀和某段后缀组成
先求一遍前缀和
对于完全包含在[1,n]的一段合法区间[L,R]
区间和为0
但由于最前面的一段合法区间的前面可能还有一段前缀
所以P[L-1]==P[R]
证明答案为n-出现次数最多的前缀和的次数
对于某个出现次数最多的前缀和
设它出现了K次
每相邻两个出现的位置对应着一段完全包含在内的区间
若该前缀和为0
则它对应着K个完全包含在内的区间
若该前缀和不为0
则它对应着K-1个完全包含在内的区间
和一个包含一段前缀和一段后缀的区间
所以某个前缀和的出现次数=某种划分的区间数
要使划分的区间尽量多
就要选择前缀和出现次数最大的那种方式
所以得证