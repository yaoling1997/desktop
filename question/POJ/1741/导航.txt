题目大意
给一颗树
每条边一个权值
求路径上的边的权和不超过K的路径数
点分治
每次考虑过重心的路径
不过重心的路径递归处理
以前是一层一层地做的
这次改成了递归版本
对于每一层
先求重心
然后从它开始dfs得到从它出发的路径信息
就是路径和
存到一个总的vector里,不妨设为M
也存到第i个儿子对应的vector,不妨设为V[i]里
然后把重心为端点的路径和完全过重心的路径
对答案的贡献加到答案中
把M和V[i]中的元素从小到大排序
然后扫V[i]中的元素
假设当前的元素大小为x
M中比K-x大一点的元素的位置为j(从0开始)
V[i]中比K-x大一点的元素的位置为k(从0开始)
对答案的贡献为j-k