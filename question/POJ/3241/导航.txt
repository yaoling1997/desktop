x:
曼哈顿最小生成树
试了这么多次总算碰对了
反正我是用平衡树去维护的,I like treap!
更n^2log(n)拍了很久终于不Wa了,一交POJ就过
但调试的路还是艰辛的,本来都打算放弃了(被呸了n次,也许是唯独我一人treap吧)
首先曼哈顿最小生成树的核心思想是尽量减少无用的边
由于所有点在一个平面上,我们要考虑平面的性质
要找一个图G的最小生成树,对于图中一个环,我们删掉环中的权值最大边使图变为G',可以保证图依然连通且G'的最小生成树的权值与G的最小生成树的权值相等
比如说我们要给一个点s进行连边
首先以这个点为原点把平面分成8个部分(见图),可以证明每个区域最多连一条边就行了
以R1为例如果R1里有两个点p,q,不妨设p.x<q.x
1:若p.y<q.y
sp= p.x+p.y
sq= q.x+q.y
pq= q.x-p.x+q.y-p.y=q.x+q.y-(p.x+p.y)=sq-sp
所以得知pq不是三角形最长边,要删也是删sp或sq
2:若p.y>q.y
sp= p.x+q.y
sq= q.x+p.y
pq= q.x-p.x+p.y-q.y= q.x-q.y+p.y-p.x
因为q.x<q.y
所以pq<=p.y-p.x<=p.y<=p.x+p.y=sp
所以pq仍然不是三角形的最长边,要删仍然是删sp或sq
所以对于R1内的多个点,只要连一条最短的边就行了
由于对称性R2~R8同理
现在的问题就是对于每一个点如何找到一个区域内的最短边了
由于对称性,我们只要考虑R1～R4
所以先将所有点按x坐标第一关键字,y坐标第二关键字从小到大排序
先看R1区域内的怎么求
对于当前一个点pk,pk+1~pn都已经存进我们的一个抽象数据结构里了,我们需要查询
我们要得到的那个点需要满足的条件是
x>xk
y-yk>x-xk=>y-x>yk-xk=>x-y<xk-yk
并且x+y最小,因为R1内的一个点的x>p.x且y>p.y
所以到pk的距离为x-xk+y-yk=x+y-(xk+yk)
xk+yk是定值,也就是要使得x+y最小了
反正我是用treap实现的,树状数组维护怎么想都有点不可思议
每个节点存第一关键字x-y
第二关键字存x+y
查询时只要查询到x-y<xk-yk且x+y最小的点就行了
所以还要在treap中的每个点维护点的下标以及以它为根的树中x+y最小值以及最小值对应的那个点的标号了
具体怎么查询就不多说了,第一关键字小于pk的第一关键字就往右边走,并用当前点的左子树的标记和当前点的第二关键字更新答案,大于就往左边走不更新答案
对于R2,R3,R4就只要翻转或取坐标相反数变到R1内就行了
把边连完再跑kruskal就行了
反正一开始没有变换坐标一直Wa,发现算R2的时候会受到R3或R4区域的点的影响,变换坐标就没有这个影响了
实验了一下确实很快
