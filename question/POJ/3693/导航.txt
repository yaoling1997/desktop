这题竟然搞了一晚上才过
首先很显然会想到枚举循环节的长度L
然后假设至少重复一次
那么子串肯定会包含s[1],s[1+L],s[1+2*L]....s[1+k*L]
中相邻的两个
然后就可以枚举长度L
枚举位置1+k*L
然后看与它相邻的1+(k-1)*L
看在相等的情况下它们能向左和向右最多能扩展到哪里
然后错位的长度是一个最短周期
循环次数就是长度/L
由于不一定可以整除
所以会产生多种情况
所以把长度丢到一个数组里
最后再按排名从小到大扫sa[i]
若扫到的sa[i]开头的某个子串可以循环cnt次
那么肯定是字典序最小的,直接输出即可
然后由于之前比较傻叉,还把原来的串反过来又求了一遍后缀数组
结果tle了
其实完全不用反过来再求一遍
因为如果对于k和k-L的最长公共前缀长度x
它mod L的余数为r
那么往前只需要看L-r位
也就是看k-L-(L-r)与k-(L-r)的最长公共前缀是否>=L-r
因为再看多一点的话,会在k-2*L和k-L时考虑到
