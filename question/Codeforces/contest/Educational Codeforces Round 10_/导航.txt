a:
直接枚举

b:
从小到大排序后
让每个奇数位的数字
和前面相邻的数字交换

c:
枚举每个左端点
看它最远能到达那个位置
个数就是位置数
其中不能包括某些给定的区间
也就是用个变量当作指针维护最远能到达的位置
每次考虑完以i为左端点后
把以i为左端点的不能包含的区间的右端点的位置-1
表示这个区间以后一定不会被包括了

d:
不久前学了用map充当树状数组的方法
nlog^2
然后想在这用一发
结果tle了
然后只好老实地写离散化版本的树状数组
题意就是给一些区间(保证区间端点不重合)
求每个区间包含的区间数量
先把所有区间按左端点从小到大排序
同时把所有区间的右端点的值插入树状数组
然后从小到大扫区间
每次都把当前区间右端点的值从树状数组中弹出
然后查询里面有多少个值小于查询的值即可

e:
看到Johnny 想到了Johnny English
进而想到了《憨豆特工》
进而想到了Rowan Atkinson
进而...
走远了
题意是给出一个无向图
每条边上有0和1两种权值
每条边只能走一次
问是否存在一条a到b的路径
使得路径上至少有一条边为1
显然对于边双连通分量
其中的每个点之间的边不相交的路径数至少为2
比如说从里面的u号点到v号点
而且必须经过其中一条边e
这样的路径一定存在
设这条边连接着u,v两个点
那么a,b,u,v肯定在某一个环中且u和v相邻
那么这样的路径显然存在
所以对于边双连通分量直接缩点即可
然后原图就变成了一些树
若a和b在同一个双连通分量里
a若走出了双连通分量
那么肯定回不来了
因为每条边只能经过一次
所以若a和b在同一个双连通分量里
有解的话当且仅当双连通分量里有权值为1的边
不在同一个双连通分量的情况就从a开始dfs
由于路径唯一
只要看这一路上的边权+点权之和是否>0即可
走不到b的话显然无解

#f:
看了半天题解都没有看懂
看了别人的代码
结合了一下题解
终于看懂了
TAT
搞了几个小时才把这个思维之弯绕了过来
首先蚂蚁们最后的位置肯定是可以求出来的
直接看作蚂蚁是穿过去的即可
然后由于不知道蚂蚁的对应位置
所以要想办法找出蚂蚁的对应位置
无论怎么爬
蚂蚁i的邻居依然是原来的那两个
相对位置不变
先把位置都分别-1方便以后的处理
把蚂蚁们按一开始的位置从小到大排序
比如说第二个例子
蚂蚁编号: 3 2 1 4
绝对位置: 1 5 6 8
相对位置: 0 1 2 3
再考虑这种情况
假设m=4
只有两只蚂蚁
蚂蚁编号 1 2
绝对位置 0 2
相对位置 0 1
假如再过1个时刻
一号蚂蚁从0爬到了3
一号蚂蚁从2爬到了1
那么
蚂蚁编号 2 1
绝对位置 1 3
相对位置 0 1
说白了就是1号蚂蚁原来对应的相对位置i
变为了现在的((i+sh)%n+n)%n
其中sh是循环位移大小
所以每有一只蚂蚁从0到n-1
sh--
每有一只蚂蚁从n-1到0
sh++
把所有蚂蚁对循环位移的贡献加起来
再对n取模(n的整数倍次循环位移相当于没有移动)
所以最后对于蚂蚁i
ans[i]=((p[i]+sh)%n+n)%n
p[i]是i蚂蚁原来对应的相对位置
然后就没了,有点难想到
必须要结合例子分析...
