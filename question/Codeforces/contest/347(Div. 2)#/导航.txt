文件名为 #x.cpp
表示x题是赛后补交的

也许是因为突然变成了unrated
少了一些人
排到了第六(弱鸡中排第六也没有什么好骄傲的)
但是由于上午gcj打崩了
重新调整了一下心态
确实打得还算满意的(至今codeforce div2排名最靠前的一次)
本来第5,结果b题fst了

所以做题时一定要
全神贯注
保持冷静
理性分析
想清楚再下手

不足的地方在于做完前四道题还剩22分钟时
就开始静不下心
于是潦草地看完E题以为这题是傻B题就直接敲了个模拟
结果连样例都没过(样例就是直接模拟的反例)
而且那时只有一个人过(可惜他最后fst了)
所以对于这种情况一定要谨慎
结果白白浪费了20分钟(还不如去hack一下别人)
a:
结论很显然
a!=b ans=1
a==b ans=a
因为gcd(a,a+1)=gcd(a+1,a)=gcd(a,1)=1

b:
设正的问号a个,负的问号b个
想着是
若n<a-b*n || n>(a*n-b)那么无解
否则有解(这之间的值显然都可以取到)
然后想如何构造解
一开始想的是让负的问号都为1
再把n+b平分给a个正的问号
结果fst了
因为有的正的问号变成了0(问号取值必须是1到n)
所以在假设负的问号都取-1时
令k=(n+b)/a,r=(n+b)%a
对于k==0要特殊处理
因为如果不特殊处理的话有a-r个正的问号的值是0
那么必须强行把它们取成1
那么再用负的问号去平衡这a-r
y= a-r
z= (a-r)/b+1
每次遇到负的问号就分担1+min(z,y)
再让y= max(y-z,0)
这样y个值就被分完了

c:
题意是给出一个缩写(不超过9位数字)
求它表示的年份
年份从1989开始计算
对于一个年份a1a2...an
它是由它的某个后缀表示
且这个后缀没有表示比它年份小的年份
这些后缀中取最小的
比如说
1989 用9表示
1990 用0表示
...
1998 用8表示
1999 用99表示(因为9已经表示过1989了)
所以对于一个缩写a1a2...ak
它是它的表示的数的一个后缀
且它表示能够表示的数字的尽量小的那个
也就是这个后缀能表示的数字从小到大枚举
先判断a1a2...ak有没有被其它后缀(比如说a2...ak)表示
再判断1a1a2...ak有没有被其它后缀表示
再判断2a1a2...ak有没有被其它后缀表示
直到遇到一个数字x没被a2...ak及其后缀表示
证明
题意是对于x
它的表示是找一个1989到x-1都没用过的最短的x的后缀
不妨设遇到一个数字为x,x没被a2...ak及其后缀表示
若x不是答案,则存在一个更大的y由a1a2...ak表示
由于aiai+1...ak(i属于1到k)都被表示了
x肯定是由一些数字再接上a1a2...ak表示
不妨设为b1b2...bka1a2...ak
由于x<y
所以会先考虑x的后缀再考虑y的后缀
先考虑x的后缀的话明显a1a2...ak比b1b2...bka1a2...ak要短
所以矛盾
所以得证
每个缩写a1...ak最多枚举k次
所以就先把a2...ak表示的数字处理掉再枚举查表即可
处理a2...ak及其后缀也同理
先看ak表示的数字,丢进set
再看ak-1ak表示的数字,丢进set
...
看a2...ak表示的数字,丢进set
再看a1...ak表示的数字,直接输出

d:
只有冷静分析才能做出题目
题意是给一张无向图
每条边是红色或蓝色
可以选一些点
被选中的点所连的边
红色变蓝色
蓝色变红色
问是否可以让所有边颜色相同
若存在一种方案
最少要选多少点
若可以的话
所有的边不是红色就是蓝色
假设最后全为蓝色(红色做法同理)
设每个点选了xi次
显然xi属于{0,1}
因为每翻两次跟翻0次是一样的
又由于要翻的总次数最少
再考虑每条边
它的变化次数为它所连的两个点的选中次数
设两个点为i,j
那它的变化次数为xi+xj
若它的颜色为蓝色
则(xi+xj)%2==0
若它的颜色为红色
则(xi+xj)%2==1
mod2意义下的加法就是xor了
可以写成
若它的颜色为蓝色
则xi xor xj==0
若它的颜色为红色
则xi xor xj==1
对于第一种情况
若xi=0则xj必须为0
若xi=1则xj必须为1
若xj=0则xi必须为0
若xj=1则xi必须为1
对于第二种情况
若xi=0则xj必须为1
若xi=1则xj必须为0
若xj=0则xi必须为1
若xj=1则xi必须为0
每个点i不为0即为1
可以想到2-sat
于是对于每个点i
拆成两个点 i和i+base
i表示xi为0
i+base表示xi为1
令X[i]=i+base X[i+base]=i
然后连边
对于第一种情况
i->j
X[i]->X[j]
j->i
X[j]->X[i]
对于第二种情况
i->X[j]
X[i]->j
j->X[i]
X[j]->i
然后跑2-sat就可以了
若i+base被访问了
那么就表示i要翻
但这里跑2-sat还要考虑一下怎样翻代价最小
若对于没有dfs到的i
从i和i+base出发看拿种翻点最少
即走经过的点的编号>base的点最少的那种方案
若两种走法都无解则整个问题无解
至于2-sat为啥不需要回溯
不会证明,白书上也没有详细解释
反正会用才是王道
