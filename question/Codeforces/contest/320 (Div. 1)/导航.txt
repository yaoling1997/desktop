a:
手贱加了个eps
结果被卡精度了
所以这种题最好用整型做

b:
这题一眼看上去感觉x都应该乘在某一个ai上
反证法
若有一个乘在aj上(i<>j)则乘到ai上ai的次数会上升,所以答案会更优
所以就枚举乘到哪个ai上再更新答案即可
把ai都转成二进制
再开个数组存一下每个二进制位上有几个1或起来
枚举ai时就把它原来的贡献删去再把更新后的贡献算上
再更新答案
所以是O(nlogn)的
一开始b数组还开小了...
所以数组要是能开大还是开大一点好

c:
cf上的题就是喜欢卡精度
误差不超过10^-6
eps开到10^-10还会被卡
开到10^-12就能过
这题就是二分加区间最大值
显然我们可以先把ai都变为非负
然后当x增大时,区间和最大值(设为A)会减小,最小值(设为B)会增大(显然)
那么当区间和最大值=-区间和最小值时即为临界
那么二分x
x比要求的大则 A<B
小则 A>B
区间最大最小值就dp即可

d:
表示正解dp看了题解和源代码想了半天都没想出来
大概是从一般求lcs来考虑
已知f[n][n]= n-1
f[x][y]表示S串前x个,T串前y个的最长公共子序列
显然我们只要考虑abs(x-y)<=1的状态
然后巴拉巴拉
反正没搞出来
然后发现还有一种贪心做法
就是我们把S中的一个字符删去,然后在某个位置上放上一个字符
考虑哪些是非法的,哪些是会算重复的
将一个子串分成几部分,把字符相同的且连续的尽可能长的每一段分为一组
一共分成了k组
譬如说
aabbbca
分成
[aa][bbb][c][a]
1    2    3  4
然后对于每一组
无论删掉哪一个
再随便插入其它字符都是一样的
就拿第一组来说
删掉第一个a再随便插和删掉第二个a再随便插是一样的
所以对于每一组只需考虑删一次的情况
设我们选的第i组的大小是g,字符为c
那么插c字符时插到与i组中的任何元素相邻的位置都是不行的,总共有g个这样的位置
再考虑第j组(i!=j)大小为h,字符为d
那么插字符d时又会多算h次
所以每一个组对答案的贡献就是n*m-n
除此之外还有别的把答案算重的情况(QAQ)
譬如说ababa变成babab就有两种变法(显然看得出来)
对于这个串的其中一截bab
把它变成aba也有两种变法
所以可以发现答案还得减去所有长度>=2的那样的串的个数
可以发现没有别的情况了(论感性的重要性)

e:
搞了半天总算过了
果然有的题目没看题解就觉得超难
看了题解后瞬间变水...
这题就是给一个字符串,只包含L和R
比如说
RRLRL
这是一个人用左右脚走出来的痕迹
他一定是左右脚轮流走
第一步不知道是左脚还是右脚
然后他的脚可以跨无限宽
他可以往回走
求一个走的方案使得往回走的次数最少
输入保证有解
一看见是构造题我就好慌...
然后掺合着题解终于弄出来了
首先设最少次数为k
那么肯定可以把这个串分成k+1个不走回头路的序列
(显然)
那么我们反过来考虑
若有k+1个不走回头路的序列
那么最多只能将它合成为走k次回头路的序列
合成就是让一个序列接在另一个序列前面或后面
然后按顺序走
若我们得到了这k+1个序列
我们只关心每个序列的第一步和最后一步
所以这些序列可以分为4类
LL,RR,LR,RL
个数分别为A,B,C,D
显然abs(A-B)<=1
否则就不合法了
然后考虑怎么拼接
对于LL和RR
那当然是一个LL一个RR交替着拼
最后顶多会剩下一个LL或RR
对于LR和RL
就先让LR们拼成一个LR,RL们拼成一个RL
对最后拼好的LR和RL
考虑它们各自的最后一步
不妨设(a=LR的最后一步R的位置)>(b=RL最后一步L的位置)
那么把a这一步放到RL后面
这样做显然不会增加走回头路的次数
那么就得到了LL和RR！
然后拿去随便拼就行了
不过要小心那种某情况没有的数据(wa了好多次......)
那么怎么弄出这k+1个序列呢?
L  L
R  R
R  R
L  L
R  R
拆点成上面那个样子
连边就像图那样连
左边的每个L都向右边的位置低于它的R连
左边的每个R都向右边的位置低于它的L连
n减去最大匹配即为序列数
因为假设把每个元素分为一个序列
一条匹配边就合并了两个序列
使分得的序列总数减少
但普通的最大匹配是n^2的
但是这个图很特殊
所以O(n)就能求出最大匹配
搞两个变量做指针就行了
然后就没了
