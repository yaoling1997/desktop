又打了一场虚拟比赛
感觉脑子不太好使...
a,b直接模拟

c的话构造一下即可
分情况讨论一下

d题又没想清楚就动手了
结果还剩20分钟大妈就来催人了
假设改把系数ai改成bi
P(2)-Q(2)= (ai-bi)*2^i=A
bi=ai-A/2^i
要是能把A算出来就好了
但是直接算出来很麻烦
可以先把P(2)转成2进制表示
要是负数就系数全取相反数再用二进制表示
p表示1或者-1
不需要取反为-1
需要取反就是1
bi=ai+(-A)/2^i
然后注意到A/2^i要是整数
不妨从最大到小考虑i
要是A/2^i很大的话(比如说大于1e15)
那么由于以后会更大
所以bi显然不会<=k
这时候直接break即可
要注意i=n时bi不能为0

e
显然最后要达到的答案不会太大
也就是只有可能是原来的某个数字到那个数字+4的范围
因为多了5的话全部减去5肯定答案更优
假设5*c<b
那么就令b=5*c
然后对于每个数字x
它最少用1的次数<5
所以就考虑x,x+1,x+2,x+3,x+4对答案的贡献
对于x mod 5=r
分别考虑相同的r对应的那些数字即可
从小到大考虑答案
先取前K个
sum存的是把前K个数字调到d[r][K]的代价
然后更新一次答案
之后就从K+1往后扫,d[r][K+1]为当前考虑的答案
由于前K个元素到d[r][K]的代价都算好了
那么对于新考虑的d[r][K+1]
把它也变到d[r][K]
然后取最优的K个
这个过程用堆维护即可
然后再加上K个元素从d[r][K]到d[r][i]的总代价更新答案
