a:
cf上头一次被人hack
原因是2016是闰年
2月有29天
我手贱写成了28...

b:
直接把那些数字处理出来
然后暴力扫看是否在a~b中

c:
前缀和

d:
有些时候不是题目太难，而是自己太懒
一看到dp
一时没想出来
就不想写
看了题解发现这题......
然后把一个该开ll的地方写成了ull
hash没那么容易卡掉......
f[i][j]
表示末尾数字为i~j
若s[i]=='0'
就是0
f[0][0]=1
f[i][j]从f[a][i-1]转移
若j-i+1>i-1-a+1
直接加到答案就是了
j-i+1==i-1-a+1
就判下大小
用hash加二分

e:
一眼看上去就是贪心
结果
呃
没写拍
肉眼调了半天
还是有个地方没看出来
有一个多小时的时间竟然都没有去写拍...
反正分了好多情况讨论
然后没打拍又发现了一些坑点
但最后还是跪了
一开始用的multiset
结果不知道为啥老re
然后改成了treap

f:
又打错变量了
还过了29个点...
这种题每次看了题解都会做
假如是RUD
那么第一步会删掉最右边那一列
把h加入答案
再执行U
会删掉剩下的格子的最上面的那一行
再执行D
不会发生删格子事件
所以只要维护xmin,xmax,ymin,ymax
表示剩下的地图
并记录方位向量(就是开个二元组记录怎么走的)
一开始是(0,0)
然后再记录
x轴最小的移动到的地方和最大移动到的地方
y轴最小的移动到的地方和最大移动到的地方
然后就有了一个n*n的算法
然后我们只需要扫两次移动的序列
并把第二次扫的时候影响了地图的位置记录一下
以后就只要扫记录的位置就行了
因为每次扫完序列方位向量都会增加固定的x和y
x和y是互不影响的
假如我们只看y
每次扫完后y方向都会加上固定的增量d
不妨设d>0
那么第二次还能影响地图的操作一定是向右走的
如果有向左走的
由于起点已经右移
向左走的最大长度是固定的
那么第二次显然无法超过向左的最大长度
由于每次扫之前(除了第一次)都会增加一个向右的增量
所以第二次可以更新地图的位置
之后也一定可以
由于每次更新都会删掉一行或一列
所以复杂度不会超过w+h
然后开个前缀和记录一下一整片的移动即可
