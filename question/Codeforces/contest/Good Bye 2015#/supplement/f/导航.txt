f:
又打错变量了
还过了29个点...
这种题每次看了题解都会做
假如是RUD
那么第一步会删掉最右边那一列
把h加入答案
再执行U
会删掉剩下的格子的最上面的那一行
再执行D
不会发生删格子事件
所以只要维护xmin,xmax,ymin,ymax
表示剩下的地图
并记录方位向量(就是开个二元组记录怎么走的)
一开始是(0,0)
然后再记录
x轴最小的移动到的地方和最大移动到的地方
y轴最小的移动到的地方和最大移动到的地方
然后就有了一个n*n的算法
然后我们只需要扫两次移动的序列
并把第二次扫的时候影响了地图的位置记录一下
以后就只要扫记录的位置就行了
因为每次扫完序列方位向量都会增加固定的x和y
x和y是互不影响的
假如我们只看y
每次扫完后y方向都会加上固定的增量d
不妨设d>0
那么第二次还能影响地图的操作一定是向右走的
如果有向左走的
由于起点已经右移
向左走的最大长度是固定的
那么第二次显然无法超过向左的最大长度
由于每次扫之前(除了第一次)都会增加一个向右的增量
所以第二次可以更新地图的位置
之后也一定可以
由于每次更新都会删掉一行或一列
所以复杂度不会超过w+h
然后开个前缀和记录一下一整片的移动即可
