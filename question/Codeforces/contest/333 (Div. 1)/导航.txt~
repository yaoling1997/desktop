d:
连数据结构都不会写了
就是边dfs边建trie树
譬如说要建节点v的trie
可以从v开始dfs
每进入一个儿子
就看trie的当前节点是否有对应字母的儿子
有就让标记变量进去
没有就新建一个儿子再进去
这样对于一个节点我们顶多话O(n)的时间建trie树
trie的节点个数就是答案
但是要把每个节点的trie树都弄出来
我们只需在搞v的trie时利用它的子树节点数最多的儿子的trie
其它儿子的按之前的方法暴力搞就行
为何?
因为这样做
每个节点顶多暴力扫log次
因为其余儿子为根的子树u的总点数size[u]<=size[v]/2
每执行一次
size[u]所在的集合的总点数至少会变成2*size[u]
因为已经把那些子树都合并了
所以是log的
为了不mle
还要用左儿子右兄弟的方法建树
当然,用vector更加无脑
不过为了练习指针还是用了左儿子右兄弟
然后农了半天
打错了变量名
head[o]表示跳到o的第一个儿子
next[i]连接的都是兄弟
即连接的都是o的儿子
ch[i]表示i这个地址由什么样的字符指过去
c[]是用来搞笑的

e:
概率和期望学得太渣了
看了题解和标程想了半天都没想出来
关键是题解和标程不一致......
最后终于想明白了题解是在说什么
并且用无穷等比数列求和推出了
初值要赋值为1/p[i][n]/100.
加.表示double类型的数字
然后感觉题解在更新的那部分有点问题
然后就投靠了标程
然后发现了这么个东西
设当前点j可以到的点从好到坏一次为v[0]~v[k]
一个点越好表示该点到n点的期望长度越小
v[0]就是n了
那么答案就是
令P[i][j]=p[i][j]/100.
(ans[v[0]]*P[j][v[0]]
+ans[v[1]]*(1-P[j][v[0]])*P[j][v[1]]
+ans[v[2]]*(1-P[j][v[0]])*(1-P[j][v[1]])*P[j][v[2]]
+...
+ans[v[k]]*(1-P[j][v[0]])*...*(1-P[j][v[k-1]])*P[j][v[k]])
/(P[j][v[0]]*p[j][v[1]]*...*p[j][v[k]])
不知道为啥是这个
然后dijkstra每次更新就是了
先确定的点的期望长度肯定最小
然后就没了
