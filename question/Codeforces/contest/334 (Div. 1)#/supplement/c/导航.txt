c:
又是好久没碰博弈了
原理早已回忆不起来了
大概就是那样子
整个游戏的sg函数的值为子游戏的sg的异或和
sg不为0代表可以赢,否则输
f(x)表示x状态可以到达的状态的值中从0开始连续的那一段的最大值+1
比如说x到达的几个子状态的f(i)有0,1,2,4,5
那么f(x)=3
x为偶数时
f(x)可以从f(x-1)转,也可以从f(x/2)连续异或自己k次转
x为奇数时
f(x)只能从f(x-1)转
这道题要分两种情况讨论
k为偶数时
f(0)= 0
f(1)= 1
f(2)= 2
f(3)= 0
f(4)= 1
x为偶数时,连续异或k次就是0了
x为奇数时,只能从x-1转
可以发现x>2时
x是奇数的话f(x)=0
x是偶数的话f(x)= 1

k是奇数时
f(0)= 0
f(1)= 1
f(2)= 0
f(3)= 1
f(4)= 2
f(5)= 0
x<=4特殊判断
x>4时
x为奇数,则f(x)= 0
x为偶数,f(x)从f(x-1)和f(x/2)转
f(x/2)直接算就是了,反正算一次是logn级别的
若f(x/2)==1 那么f(x)==2
若f(x/2)!=1 那么f(x)==1
然后把n个数字的f(a[i])异或一下就没了
