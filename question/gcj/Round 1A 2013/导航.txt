a:
退出求和的通项
二分答案

b:
看到只有455个人过
还以为是什么难题
题意就是给n个活动(n<=10000)
每个活动有一个价值v
然后主人公一开始有E点能量
每次都可以往这个活动中投入一些能量x
不能超过当前拥有的能量
所获得的收益就是v*x
每次经过一个活动后主人公都能获得R点能量
求收益最大值
其实就是贪心然后维护一个单调栈即可
当然,由于要考虑到任何时刻能量不能超过E
所以其实并不是严格单调的
但是任何对以后的答案有影响的部分
其中的v值都是单调不增的
然后每扫到一个i,都把R的能量给它
若栈顶的v<它的v
    若栈顶的J+它的J<E,就把栈顶的能量全给它
    再把它弹掉    
    否则把E-它的J给它
    同时维护答案

c:
小数据贪心直接搞
大数据按照题解的方式搞
还是没过(可能这组数据比较坑,当作练习时数据不会换)
但这么搞还是很科学的
就是对于每k个乘积,选择这么n个数
使得是这么n个数的可能性最大
因为不考虑重复
所以所有可能的n个数的情况数只有18564种
这也能用组合数学算
就是插板子,板子从左到有编号为2到8
然后往12个球右边添6个球
设左边12个球为红色
右边6个球为蓝色
然后插板子
8号板子固定在最右边
然后i号板子到左边离他最近的板子之间有有多少个红球
就代表i取多少个
i=2就是左边有多少个红球2号元素取多少
所以总数是C(12+6,6)=18564
然后在已知乘积的情况下算哪种取值最有可能
就是算下每种取值在乘积为k的情况下的条件概率
设Pr(a|b)是在b的事件下a发生的概率
根据贝叶斯定理
Pr(a|b)=Pr(ab)/Pr(b)
假设只有一个乘积
即K=1
并且乘积为p
设当前考虑的选数集合为A
那么我们要选一个Pr(A|p)最大的A
Pr(A|p)=Pr(Ap)/Pr(p)
Pr(p|A)=Pr(Ap)/Pr(A)
Pr(Ap)=Pr(p|A)*Pr(A)
Pr(A|p)=Pr(p|A)*Pr(A)/Pr(p)
Pr(A)可以预处理出来
答案为n!/(a2!*a3!*...*a8!)/(M-1)^n
其中ai是A中i的出现个数
(M-1)^n为全部排列的个数
n!/(a2!*a3!*...*a8!)为A在这(M-1)^n的出现次数
就是全排列除掉重复排的情况
然后Pr(p|A)可以预处理出来
就是2^12枚举所有可能的乘积的情况
丢到A的map里
Pr(p|A)=M[A][p]/2^12
反正最后开了O2跑了10分钟还是incorrect
本来想着k组乘积应该是Pr(p1|A)*Pr(p2|A)*...*Pr(pk|A)
结果改成比较
Pr(A)*Pr(p1|A)/Pr(p1)*Pr(p2|A)/Pr(p2)...*Pr(pk|A)/Pr(pk)才过
