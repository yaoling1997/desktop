a:
对于第一个设备枚举它和哪个充电器匹配
然后把位置不同的改了
这样要改的情况就唯一确定了
再拿剩下的充电器和剩下的设备看能不能一一匹配上
能的话就更新答案

b:
枚举每个点为根
树形dp一下
f[i]表示以i为根的子树要是binary tree的要删的最少节点
转移就是要么把后代都删了,要么从中选两个儿子x,y
f[x]-size[x],f[y]-size[y]分别是第一和第二小

c:
给了两份随机生成排列的代码
一份随机得好(good)
一份随机得不好(不是很容易看出来)(bad)
然后有120组数据
每组数据1000个数字
每组数据都有50%的概率选择good生成
另外50%为bad生成
要求判断每组数据是good生成的还是bad生成的
要求判断正确至少109组
可以多次提交
以前从来没有做过这种题
然后正解之一是基于大数据分析
还有一个没仔细看
就是bad的生成方式使小数字放的位置
相对于good更容易放在靠后的地方
然后按照bad随机10000组
设新的排列为P[]
统计一下每一个i,P[i]<=i的个数x
然后发现x比较集中于472
而good是集中于500的
然后对于每组数据
统计一下每一个i,P[i]<=i的个数x
若abs(x-472)<abs(x-500)就输出BAD
否则GOOD
感觉random()里写成
return rand()%o;
和
return 1.0*rand()/RAND_MAX*o;
都差不多
应该是mod 的数比较小的原因
