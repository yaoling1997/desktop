x:
维修序列，总算独立完成了，太棒了！
用splay完成序列的各种操作
数据规模与约定:
你可以认为在任何时刻，数列中至少有1个数。
输入数据一定是正确的，即指定位置的数在数列中一定存在。
50%的数据中，任何时刻数列中最多含有30 000个数；
100%的数据中，任何时刻数列中最多含有500 000个数。
100%的数据中，任何时刻数列中任何一个数字均在[-1 000, 1 000]内。
100%的数据中，M ≤20 000，插入的数字总数不超过4 000 000个，大小不超过20MBytes。

我从早上8:00开始一直打到晚上9:00终于过了！(好久没打splay了)
其实大体思想很简单，就是细节太恶心，大体框架我一个多小时就打完了，但是真的是有很多细节啊，况且我前一天就开始谋划这道题了
支持6个操作，插入一段数字，删除一段数字，翻转一段数字，更改一段数字，求一段数字的和，求当前序列中最大的区间和
这题数据范围我找了半天才找到，BZOJ也不能这么坑吧，数据范围都不给
询问<=20000 插入的数字个数不超过4*10^6,任何时刻数列中最多含有5*10^5个数
对于插入，将插入的数建成一颗平衡树，并与原树合并
对于删除，split以后遍历一遍mid，把它的节点回收(把指针存到一个栈中)
对于翻转,打上标记，pushdown()时要把标记传给左右儿子,并交换左右儿子的指针以及左右儿子的前后缀最大值(左儿子的前缀最大值与左儿子的后缀最大值交换，右儿子同理)，一开始我就没注意这里，结果Wa到最后才发现
对于更改一段数字，直接打上标记，注意mt()更新时要对打上标记的儿子特殊处理:
因为若儿子打上这个标记，则这棵子树中所有节点的值都等于标记的值，所以计算时特殊计算一下(子树节点数*标记的值=子树的sum)
求和的话维护一个sum就行了
求当前序列中最大区间的和可能是左右子树的最大区间，左子树的最大后缀加上当前点，左子树的最大后缀加上当前点再加上右子树的最大前缀，右子树的最大前缀加上当前点，如果打这么多个if肯定划不来，所以左子树的最大后缀要是<0则r1=0否则r1=左子树的最大后缀，所以r1= max(ch[0]->maxr,0)就行了,
右子树一样l2= max(ch[1]->maxl,0)然后maxm=max(ch[0]->maxm,ch[1]->maxm)
maxm= max(maxm,l1+r1+v)就行了
当前区间的前后缀最大值
=max（ch[0]->maxl,ch[0]->sum+v,ch[0]->sum+v+ch[1]->maxl)
化简一下就是max(l1,suml+v+l2)
右子树同理
由于可能会受到null节点(人工建立)和0号保护节点的干扰，我们把0号节点的值赋为-oo，对null特殊处理
另外，直接交BZOJ要5s，开个读入优化就只要3.6s了，所以有时候还是要开读入优化的
每个节点的前缀,最大和,后缀初始的时候都要变成-oo,以防序列中全是负数的数据
注意不要被保护节点(序列最左边的0号节点)影响,max-sum时把它切掉再输出再合并
x1:
暴力
x2:
块状链表
自己yy的,非常丑也非常慢,正确性也不能保证
(调一下块的大小在线下可以全部正确,只是会TLE,大概最慢的点要5s吧)
调了半天啊
块状链表实现其实也不容易,但是扩展性很强
块的大小在size~2*size之间,size一般设为n^0.5
块状链表插入一般先分裂块,然后再插入已经建好的块
定位的话直接扫
翻转的话先split然后整块打标记,再整体翻转(由于是用双向链表实现的,直接交换左右指针就行了)
删除的话直接split再 merge
求和求最大值就维护个标记什么的
不过不知道什么原因,过了很久再来测,发现最慢的点只要1s多一点了,而且不会萎(以前明明TLE的,难道代码放久了还有攻击加成？)只是会爆64MB,然后我改了下回收节点就过了BZOJ了,真是莫名奇妙,没开读入优化6.9s,开了后5.4s
注意在location的位置要下放标记,因为它将被切开,merge时也要
其实块状链表的速度主要取决于分块大小,所以至于大小怎么分要具体情况具体分析,多尝试几次
还有一个优化就是每次更新后合并两个size之和小于2*size的块,注意是小于不是小于等于,因为插入的块的大小就是size的
x3:
一年后又用splay打了一遍
