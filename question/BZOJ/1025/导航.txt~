[SCOI2009]游戏
糊里糊涂过去了,转化有点晕
首先这玩意是个置换,既然是置换,就可以拆成循环节的形式
比如说 1 2 3 4 5 6
置换为1->2 2->3 3->1 4->5 5->4 6->6
变成了(1 2 3)(4 5)(6)
发现循环节长度之和恰好为n,既然置换后要满足再次回到 1 2 3 4 5 6那么排数就是循环节的lcm
问题可以转化为a1+a2+...ak=n中有多少个不同的lcm
由于置换大小为1的循环对lcm没有影响
于是问题又可以转化为a1+a2+...ak<=n中有多少个不同的lcm
由于ai可以拆成若干素数乘积,要求的那玩意先除掉它们的gcd
然后问题又可以变成若干只含一个素数的次方的数的和<=n有多少个不同的lcm
然后可以用DP解决
先预处理不超过n的素数
设f[i][j]表示前i个素数及其次方之和不超过j的方案数
最后答案就是sigma　f[top][j](j<=n)了
具体的转移就是f[i][j]= sigma(f[i-1][j-p[i]^k])(k>=0且p[i]^k<=j)
但是k=0时要特判,转的时候是从f[i-1][j]转而不是f[i-1][j-1]转,原因是k=0时相当于不选
