[NOI2007]生成树计数
总算过了,农了一晚上加一下午
状态压缩维护连通性的DP好像还从来没有打过,就算状态压缩的DP也很少打,所以一开始我感觉很不好打
其实一开始我在打行列式,当然是n^3的,但是发现用gauss消完后再乘会爆,因为小数没法模,不过模意义下的高斯除法直接变成*逆元就行了
行列式有什么用?其实也不知道
然后这道题正解不用行列式
正解是维护连通性的状态压缩DP
k个点一压,用最小表示法表示联通情况
然后转移时考虑新点怎么和前面的点连就行了
状态数很少,5个点的状态总共52种
我一直以为状态转移很难弄,其实弄的时候发现没那么难,直接爆枚就行了
首先要把状态都枚出来,枚举每两个点之间的边有还是没有,如果有环的话就不行,否则给这个最小表示法的方案的值+1代表这个最小表示法表示了几种情况,把所有最小表示法弄出来的值标个号,再建立相互映射,这样方便一些
弄出来的方案值就是一开始的初值
然后对于每种状态的转移也是暴力枚出来,是用一种状态推另几种状态,枚的时候要注意两种情况
1:不能跟相同颜色的点连,否则会出现环
2:如果当前状态所有点只有一个与最左边的点的颜色相同,那么新的点一定要和最左边的点相连
然后可以用一个矩阵来描述转移
然后就可以用快速幂了
然后用向量和矩阵相乘就行了
最后的答案就是全部连通(11..1)的那个状态的值了
