[Noi2008]道路设计
见过变态的DP,但没见过这么变态的DP
过程很繁琐,调了半天
首先它肯定是个树,如果边数不是n-1,那么就无解
首先它的最小不便利值是很小的,20以内吧,可以考虑用树形DP
不便利值从小往大的枚,直到方案数不为0,那么当前枚的不便利值就是答案
然后一二问可以同时解决了
设f[i,b]表示最大不便利值不超过b,i号点向儿子连两条边的方案数
h[i,b]表示最大不便利值不超过b,i号点向儿子连一条边或不连的方案数
然后有
f[i,b]=Σ(h[j,b]h[k,b]Π(f[l,b-1]+h[l,b-1])) (j,k,l为i的不同的子节点)
h[i,b]=Σ(h[j,b]*Π(f[l,b-1]+h[l,b-1])) + Π(f[l,b-1]+h[l,b-1]) (j,l为i的不同的子节点)
然后还有边界的判断
若b==0
f:
i的子节点数不为2的话
f[i,b]= 0
否则f[i,b]= h[v1,b]*h[v2,b]
h:
i的子节点数==0
h[i,b]= 1
子节点数==1
h[i,b]= h[v,b]+h[v,b-1]+f[v,b-1](连1条或不连)
其它的话h[i,b]= 0
然后发现是个n^3logn的DP,然后把它优化到nlogn
如果连乘那块用一个变量记录然后到时候再除的话是不行的,因为模不一定是质数,而且f[i][b-1]+h[i,b-1]有可能为0
然后就干脆记录前后缀的连乘得了
sf[i]=sf[i+1]*(f[i][b-1]+h[i,b-1])
pf[i]=pf[i-1]*(f[i][b-1]+h[i,b-1])
i表示当前点的第几个儿子
特别的
pf[-1]= 1,sf[len]= 1
然后设
r0= Π(f[l,b-1]+h[l,b-1])
r1= Σ(h[j,b]*Π(f[l,b-1]+h[l,b-1]))
r2= Σ(h[j,b]h[k,b]Π(f[l,b-1]+h[l,b-1]))
r0和r1都很好办,r0就是全乘起来,r1就是for i一遍然后把pf[i-1]*h[v][b]*sf[i+1]全加起来就行了,但r2有点麻烦,确实也挺恶心的
然后如果j是固定的话,求出来就是线性的
但j不是固定的,也没关系,有一种可怕的递推!
设C[i]表示固定i的和
即C[i]=Σ(B[j]*Π(h[k,b-1]+f[k,b-1])) (0<=i,j,k<len ,i<=j,i<=k,j!=k)
C[len-1]= h[g[o][len-1]][b]
C[i]=C[i+1](f[v][b-1]+h[v][b-1])+h[v][b]sf[i+1]
然后r2= Σ(pf[i-1]h[v,b]C[i+1]) (0<=i<len-1)
然后想了半天发现确实是对的,不信自己拆一下就知道了
然后还没完,发现它那个模非常痞,如果模成0的话会以为方案数是0,但好在它的模只有一个比较小,是2,然后如果模是2的话就先把模扩大成它的倍数(1e9+8),最后再模2就行了
