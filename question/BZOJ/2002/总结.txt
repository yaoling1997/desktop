[Hnoi2010]Bounce 弹飞绵羊
x:
LCT，
好久没打LCT了，而且这玩意才学会不久，得多打打。
这题很容易看出来可以建出一颗树，对于这种形态会变的树，就用LCT吧。
自己建个根节点，表示羔羊被弹出去了
access后还要splay，以统计查询的点的祖先有多少个。
修改就相当与splay了，splay后想怎么搞就怎么搞
2s多
x1:
暴力
x2:
分块，
没怎么打过分块，所以有点丑，还是羔羊教的这道题怎么分块。
虽然线下对拍会莫名其妙死循环，但是可以交过，4s多
而且代码量已经接近LCT了，不过略小一点
每个块中的元素维护跳到下一个块中最近的元素要跳多少次
或者直接跳到下下个块,下下下个块......
这样做,查询时是n^0.5,修改也是n^0.5
x3:
经过羔羊的指导，我分块时不再实实在在地分成size个块，分开存起来(一开始打分块时刘汝佳是这么做的，也就照搬了)，时间瞬间缩到2s多一点，比LCT还快。虽然判断时还保留了很多原来的习惯，但是没有实实在在地另外开辟空间存块，代码短了点，而且更快了。
(虽说代码短了点，但也要1KB多，别人几百B的真是太神了！)

现在再来看这个LCT,简直丑到一定的境界了


















这道问题可以用分块解决
把n个数分成B块,每块n/B个元素
编号为i的装置对应的块的编号为i/B
令f[i]表示i跳到的不与i在同一个块且离i最近的点的标号
令g[i]表示i跳到f[i]的步数
首先预处理f和g
令c[i]表示i的弹力系数
从大到小扫i
f[i]= i+c[i]
若f[i]>=n表示zxa在i处一步就跳出了边界，就令f[i]= oo,表示跳出边界
若i和f[i]在同一块中
由于i+1到n-1的f,g已经处理好了
所以令g[i]=1+g[f[i]],f[i]=f[f[i]]
若i和f[i]不在同一块
就令g[i]=1
对于查询操作(i,j),就直接沿着f[j]跳,中途累加g[j]的值即可,直到j跳出边界
对于修改操作(i,j,k)
令c[j]=k
设u,v分别为某个装置的编号，u/B=j/B且不存在v,v/B=j/B且v<u
修改j的系数只可能会影响u到j这一段的装置的f和g
所以令i从j枚举到u并维护f[i],g[i]即可
复杂度O(mlog(n))
