[Zjoi2013]K大数查询
明明是n(logm)^2的,怎么这么慢呢?
线下测最慢的点都要1.7s,BZOJ上总共跑了15s多
一开始还看错题了,以为是区间加数求区间k大,这道题是区间加入一些数,求区间k大
然后我就不会做,看题解
以前一直以为线段树套线段树没多大用,今天总算是长见识了
这道题用线段树套主席树(主席树也是线段树,只是用来维护值域的)
线段树中套两颗主席树,一颗表示标记,一颗表示值
最有意思的是不要标记下放,而是在查询的时候把标记算进去
如果区间加一个数v,若当前线段树中的区间刚好包含于查询的区间的话,就打上标记(sig表示打标记的主席树,代表这段区间都加入了一个v,如果有相同的元素加入也没关系,大不了size++就行了),然后return。否则在a维护的主席树中的对应元素加上y-x(由于是左闭右开,y-x代表查询区间与当前区间相交部分的长度)在递归处理左右子树
查询的时候也很简单,像做带修改的区间K大那样(单点修改,区间查询k大),只是要注意打上去的标记,算的话就是标记sig的size要乘上查询的区间与当前线段树区间的交的长度,值a就直接乘1就行了,标记和值都丢到栈里,用w[i]表示栈中i号元素的要乘多少,然后那样子算就行了,由于是k大(以前总是在求k大时求成k小,不过只要区间长度-k+1转化为求小的就行了,这次直接求k大),所以是累计右子树的size与w的乘积,然后求就行了
实现没太多细节,只是由于是左闭右开,maxlongint+1就爆了(由于有负数,不能用unsigned int),索性全开ll,只是要小心不要爆空间了
