[NOI2009]二叉查找树
一开始以为很难,看了题解后还是以为很难,但打起来发现还是挺轻松的,20分钟左右,还是1A
这道题是DP,往往这种复杂度比较奇怪的题都要留心想想是不是DP
DP的时候要利用treap的性质
它是一颗平衡树,所以就可以利用中序遍历转化为区间DP
中序遍历就是把所有点按数据值从小到大排个序
设f[i,j,b]表示i~j这一段根结点权值>=b的最小代价,因为它是小根堆
权值可以离散化,那一维就可以开下了,主要是用来解决后效性
然后从i~j中扫每一个点,考虑它为根时的最小代价
f[i,j,b]= min(f[i,k-1,b]+f[k+1,j,b]+sum[j]-sum[i-1]+K)
sum[i]表示前i个点的频数和
设k的权值为x,若x>=b还可以继续转
f[i,j,b]= min(f[i,j,b],f[i,k-1,x]+f[k+1,j,x]+sum[j]-sum[i-1])
因为既可以改小一个点的权值,又可以改大一个点的权值,所以分别递归处理两边
然后还有边界条件f[i,i,j]
设j的权值为x,频数为p
若x>=j f[i,i,j]= p;
否则f[i,i,j]= p+K,因为要把权值改大
答案就是f[1,n,i]中挑最小的就是了
