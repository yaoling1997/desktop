按树链剖分的样子维护dfs序
给一棵树,3个操作
1:换根
2:将一条链上的点全改为同一个值
3:查询一个点为根的子树中的最小值
链赋值想到了树链剖分,查询子树想到了树的dfs序(欧拉遍历)
这题要将这两个玩意结合一下
首先把这棵树树链剖分了,把子树节点数目最多的儿子存到next[]中
然后再从自己设定的根(不妨设为1号点)dfs
优先走重边,再走轻边
走完后得到树的dfs序
再dfs一遍,找到每个节点在重链上的最上端的那个点
然后处理倍增表
然后建立线段树
建立线段树时注意对于同一个树上节点映射到的两个节点
给靠左边的那个赋值为树上节点的值,另一个赋值为+oo
对于修改,就像树链剖分那样修改,不过修改的是dfs序列
所以从dfs序列中扣出重链,然后打标记...
由于第一遍dfs时优先走重链,所以重链上的点在dfs序中是连续的
所以就比较好扣
对于换根,没必要真的换根,搞个变量记录他规定的根是哪个节点
对于查询,要分三种情况,设查询的节点标号为x
一:
x=id
直接在线段树中查询整个区间的最小值
二:
id不在x的子树中
直接查询x的子树
把x的左映射点和右映射点表示的区间丢到线段树中查询最小值
三:
id在x的子树中
用倍增找出id在x的哪个儿子所管辖的子树中,不妨设那个儿子为y
查询时就忽略以y为根的子树就行了
具体来说就是在线段树中查询
1~y的左映射点的标号-1 和 y的又映射点的标号+1~最右端 这两个区间的最小值
然后就没了
