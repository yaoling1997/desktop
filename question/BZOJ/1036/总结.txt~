这应该是我BZOJ上第一道第一次一提交就A了的题目，看来数据结构题确实要拿暴力拍拍，而且我还是第一次写树链剖分呢，一A确实很爽，这道题也调了蛮久，第一天晚上构思了一下，并打掉了一点，第二天到机房接着打，一直到11：00，也许是第一次写，有点丑，所以不是很快，代码量也比较大，毕竟自己YY的成分太多了。
x:
树链剖分加线段树维护,找LCA
预处理时要记录它的重儿子
树链剖分后把一条链上的点弄一个新的标号x[i]= tot，同时用y[tot]=i建立互相映射。c是记录一开始的点权。root[i]维护i(原)所在的线段树根节点。f[][]倍增用的,zz记录当前点该往哪边走。size[]子树有多少节点。vector<int>g[maxn]用来存图的,par[]记录一条链上最靠近根节点的点,fa[]每个点(原)的爸爸。
按深度排序后轻重链剖分
节点重新标号,所有线段树存一个数组中
线段树中的节点用top
大体思路是找到lca后开始在线段树之间跳来跳去(当然是不断逼近lca)直到到达lca，一路上维护信息就行了,要是lca的深度小于当前线段树最左端点的深度的话，那么左端就是x[左端点]，
右是x[当前点]+1(左开右闭)。更新后当前点变为线段树最左端点的父亲，在另一颗线段树内接着跳。如果深度大于，就只要跳到lca就行了，左端是x[lca]，右端仍然是x[当前点]+1，跳到lca就可以结束了。
本来有很多线段树的，但是开在一个数组里
x1:O((n+m)^2)暴力,对拍专用
x2:
LCT,农了一下午加晚上终于农出来了，当然不是像树链剖分一样好YY，本来想不用splay记录父亲的，侃农说一定要记父亲，我还不信，自己狂YY,先是找到了比较好的定位到根的方法，再是找到了比较好的查询方法，但是发现还是不行，反正就是调不出来，其实理论上说应该是可行的，但是搞出来万一很麻烦的话也没有必要。搞到晚上8：00决定弃暗投明。但是我打splay一向都不记录父亲(一般是维护个序列什么的，有必要吗？)，自己yy了一下，还是wa,样例都过不了，侃农说往上splay的话左儿子右旋，右儿子左旋。我一开始没有把父亲的父亲的ch更新，狂wa，农了半天才发现是这个问题。改了后还是wa,然后发现莫名其妙的出现环了，于是农了一会，发现rotate时不是o->par->ch[]而是k->par->ch因为o->par已经赋值为k了。
求lca的时候求教了品农，把v看作父亲，一直旋，最后lca一定是par为null的那个点，为什么要access3次呢？因为对应两条不同的链差不多就是这样了
x3:
x的更新版本

