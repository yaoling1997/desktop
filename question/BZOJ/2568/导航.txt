细节比较多,但打起来挺轻松的
对于询问k,超过k的部分都不需要考虑,只要考虑0~k位
对于集合中的每个数字,把0~k位形成的数字存起来
第k位为1的数字在2^k~2^(k+1)-1内
所以对于每一个询问k,我们就看这范围内有多少个数字
考虑到有个ADD操作,搞个变量sum记录当前集合加了多少
对于查询k,本来是查询2^k~2(k+1)-1
现在变成了2^k-(sum&2^k)~2(k+1)-1-(sum&2^k)
因为高于sum的高于k位的部分不会对询问有影响
又由于有修改操作,就用树状数组维护区间和
f[i][j]表示k==i时,数字<=j的个数
要开16个树状数组
对于插入x,实际上插入的是x-sum
用map记录一下x-sum的个数,删除时就在树状数组中减去相应的部分
由于x-sum可能是负数,负数的二进制表示为正数的二进制表示取反+1

-1=11111111 11111111  11111111 11111111 
-2=11111111 11111111  11111111 11111110
...
插入就枚举i,把0~i的部分插入i的树状数组中

求和的话要讨论
比如k=2时,L=100,R=111,设sum=1011,那么实际要计算的区间就是[001,100]
在k=2的树状数组中统计就行了,这里是没有进位的
假设sum=1110,其它不变,那么求和区间变成了[000,001]
但是[110,111]这个区间也是符合的
因为加上sum后变成了[100,101],在L,R内
其实这段区间就是负数对应的区间,也就是[-2,-1]对应的区间
-1=11111111 11111111  11111111 11111111 
-2=11111111 11111111  11111111 11111110
所以这段区间直接用[(L-sum)&(2^(k+1)-1),-1&(2^(k+1)-1)]搞出来
然后把这两个区间的值加起来就行了
至于为什么不能只开一颗树状数组
因为小数字+sum会进位,可能导致一个数字被算多次...
