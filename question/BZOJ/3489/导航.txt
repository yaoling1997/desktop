终于用k-d tree过题了
k-d tree好厉害
貌似建树复杂度是O(nlogn)
查询复杂度是O(n^(1-1/d))d是维度
1维是特例,查询肯定不是O(1)的啦
唐老师告诉我的复杂度...
这题对于每个点i
记录它左边离它最近且值相同的点last[i]
右边离它最近且值相同的点next[i]
然后对于每组询问(l,r)
相当于找到一个i
满足:
l<=i<=r
last[i]<l
next[i]>r
且a[i]最大
于是我们可以把每个点i变成三维的带权的点(x,y,z)
x对应i
y对应last[i]
z对应next[i]
对于查询,就是查询一个空间range[i][0]~range[i][1]
前一个[]是维度,后一个是范围
我们要查询在这个空间内的权值最大的点
然后就想到用k-d tree了
虽然感觉k-d tree很暴力,但它就是能过...
建树时每个节点额外维护一个变量M表示当前子树的最大权值
查询就是若当前空间包含于查询的空间
就直接用当前空间的最大值去更新答案
否则看表示这个空间的点是否属于改空间
属于就拿去更新答案
然后看它的左右子树是否与查询空间有交集
有交集就递归到那个子树继续查询
然后就没了
很无脑,很暴力,可就是能过...
还有建树时的排序可以直接O(n)地搞,我为了偷懒,直接用了STL的快排
好像都不知道快排怎么打了...
