Tyvj 1730 二逼平衡树
x:
树状数组套treap+二分
树套树打少了，所以调了半天。
一开始算了一下复杂度，O(nlog(n)^3）再加上各种常数，应该有点困难，不过总时间限制为10s，还是有希望的。
首先初始化树状数组，使每个点都管辖从当前点开始往前长度为lowbit(o)个区间，并把这些点加到treap中。
1号操作就是从l-1查询一次，从r再查询一次，统计出1～？中有多少个数字小于k，k的排名就是sum1-sum+1了
2号操作就是不断二分答案，然后不断重复一号操作，如果排名靠后，则往小的二分，排名考前则往大的二分，我的find1中k是排名，彭宇翔说二分可以不断逼近答案，想一想也确实是这样的，起始可以发现答案是不端逼近临界点的，手玩一下发现无论怎么二分，l都是答案。
3号操作就是树状数组的更新了，把原来的那个值删掉再插进去，treap不是splay，可以找到点后一路旋上去。
4号就是。。。。。。
首先可以保证如果在一段区间内值小于一个点的点数与z相同，这个点的值一定大于等于z。
所以在找前趋时前趋肯定是小于前趋的点数=小于当前值的点数-1的那个点，也就是排名前一位的点
5号的话为了避免相同，应该先将值+1，然后与它排名相同的点了。
x1:
暴力
x2:
线段树套线段树,一个维护值域
空间消耗太大，明显不能交，但是是正确的，而且速度更快
x3:
分块，慢出翔，不解释，时间复杂度应该是nlog(n)^2*n^0.5
分块没分多少次，有些细节要注意:
比如说我块的起始编号为1，size为(n^0.5)，表示一个块中有多少个元素。
由于是用vector存的，块数组开大一点也没事，而且size是随n变的。
当读到一个区间l,r时，查询当前询问的值的排名要先花n^0.5的时间处理l所在的块，再花n^0.5的时间处理r所在的块，对于中间的块，由于它们是有序的，直接二分位置即可(lower_bound过于神奇，对于vector好像不能直接减得出当前块中有多少个元素是小于询问的值的)。因为还有区间k大，没辙了，只能二分答案，然后对于每个mid求一次排名，(二分的条件总是令我想半天，有时候一不注意就萎了，跟着暴力慢慢调吧)，使答案不断逼近临界点(很神奇吧！)。这一步就是log(1e8)*log(n^0.5)*n^0.5很费时间，所以比一开始打的树状数组套treap还慢。
所以分块是有局限性的
