虽然想到了异或应该按位考虑
但是还是没有做出来
首先要求答案可以按位考虑
假设我们要知道ans的第k位是否为1
就是要知道有多少对ai+aj的第k位为1
若有奇数对,那么第k位为1
否则为0
若ai+aj第k位为1
等价于
(ai+aj)mod 2^(k+1)>=2^k
又因为aimod2^(k+1)+ajmod2^(k+1)<2^(k+2)
所以(ai+aj)mod 2^(k+1)>=2^k
当且仅当
2^k<=aimod2^(k+1)+ajmod2^(k+1)<2^(k+1)
或2^(k+1)+2^k<=aimod2^(k+1)+ajmod2^(k+1)
即满足
2^k-aimod2^(k+1)<=ajmod2^(k+1)<2^(k+1)-aimod2^(k+1)
或2^(k+1)+2^k-aimod2^(k+1)<=ajmod2^(k+1)
对于每个i找有多少个j满足以上的条件
只要用k个线段树维护aimod2^(k+1)即可
但是k个线段树同时开出来的话会mle
所以把所有询问读进来
一位一位的考虑即可
这样就只需要一颗线段树的空间了
利用线段树可以很简单地维护修改与查询