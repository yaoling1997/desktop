好久没打后缀数组了,被坑了好久...
对于一个子串,它一定是某个后缀的前缀
所以子串个数就是所有后缀的不同前缀数
后缀们按字典序排好序后,考虑每个后缀对子串个数的贡献
设V[i]表示字典序排名第i的后缀比i-1的后缀多出的子串个数
V[i]=len-sa[i]+1-height[i]
sigmaV[i]就是子串的个数了
因为排好序后,相邻两个后缀的公共前缀都尽量长了,所以每个串都尽可能地去重了
我只能感性地理解,难以理性地证明...
自然,每个子串的字典序也是从小到大排的
所以,对V[i]来一遍前缀和,二分找k大,找到对应的后缀,再取对应的长度
设找到的后缀为suffix(sa[i])
子串长度K=k-V[i-1]+height[i]
但是题目还要求子串的l最小,这个子串不一定只是一个后缀的前缀
所以还要二分左边界,右边界
只要LCP[i,j]>=K,左端点能左就左,右端点同理,离i越远,同一侧的lcp[i,j]越小
再利用RMQ找到端点最左的那个前缀有该子串的后缀
然后就没了
注意RMQ取log时不要四舍五入,只要+eps再取下整就行了
