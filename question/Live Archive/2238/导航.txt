题意是给定m个内存和n个程序
(m<=10,n<=50)
每个内存块有mi的大小
每个程序i有ki个内存限制
每个限制用si表示
对应的有ki个t
保证si<si+1
若给程序i m的内存
若m<s1
那么程序无法运行
否则它的运行时间是小于等于m的最大的那个s对应的时间t
求最小平均回转时间和它的调度方案
平均回转时间就是
每个程序的等待时间+它的运行时间之和
再除以总程序数n
说白了就是要让所有程序的等待时间+运行时间之和尽量小
若对于某个内存块,其中有k个程序依次运行
那么总的回转时间就是k*t1+(k-1)*t2+(k-2)*t3+...+tk
那么第i个程序的回转时间就是t1+t2+...+ti
第一个程序就是倒数第k个程序
若Ti为倒数第i个程序在这个内存块的运行时间
那么它对答案的贡献是i*Ti
所以总的回转时间就是T1+2*T2+...k*Tk
由于一个内存块最多运行n个程序
可以每个内存块i对应n个点
即第j个点表示改内存块倒数第j次运行的程序是哪个
然后就想到最小权匹配(边权取反后就是最大权匹配了)
然后就想到了KM
然后就是n个程序向m*n个点连边
对于程序A,第i个块的第j个点连权值为-W[A][i]*j的边
第i个快第j个点可以重新编号
然后跑最大权匹配(KM算法)
虽然X集合中只有n个点,Y集合中有n*m个点
但是只要让X集合中的每个点都找到与之对应的Y集合中的点就行了
所以并不需要在X集合中增加n*m-n个没用的点
得出回转总时间
在通过匹配关系
输出第i个程序在第j个块中
从什么时候开始运行到什么时候结束运行
然后就没了
虽然看上去是O((n*n*m)^2)
但还是挺快的
