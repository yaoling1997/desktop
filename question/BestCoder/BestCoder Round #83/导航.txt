1001:
第一题题意是
给一个含有n个元素的集合A
定义A的子集B
B的值为B中元素最小值
定义
Sodd为所有元素个数为奇数的B的最小值之和
Seven为所有元素个数为偶数的B的最小值之和
求abs(Sodd-Seven)
一开始还想麻烦了
打算把Sodd和Seven求出来后在得到答案
于是就出来了这么个蠢笨的算法
将元素排序后
枚举最小元素
然后算有多少个元素个数为奇数的子集以这个元素为最小值
和有多少个元素个数为偶数的子集以这个元素为最小值
因为最小值确定后比它大的元素随便选,只要个数满足就行
但实际上只需要将数组排序后输出最大值即可(不排序也行)
因为按照那个算法的话
对于x,比如说有L个元素比它大
那么x对Sodd的贡献为x*(C(L,0)+C(L,2)+C(L,4)+...)
对Seven的贡献为x*(C(L,1)+C(L,3)+C(L,5)+...)
后面那陀组合数的和其实是相等的
所以相减就没了
除非L==0
也就是x为最大值的时候

1003:
题目大意是给一颗无根树
然后选一些叶子节点,给他们附上点权
然后要你给剩下的点定权值
每条边(u,v)的边权定义为u与v的点权差值的绝对值
使得边权的最大值最小
对于n==2的情况直接特判即可
显然最大值最小会想到二分
二分边权最大值m
若m>ans则肯定存在一种满足最大值不超过m的方案
若m<ans则肯定不存在一种满足最大值不超过m的方案
然后就转化为了判定性问题
选一个点为根(为了方便起见,选非叶子节点为根)
然后树形dp即可
对于每个树中的节点
维护它的取值范围
比如说被选中的叶子节点i,它的权值为w
那么它的取值范围为[w,w]
那么它父亲的取值范围必须是[w-m,w+m]
超过这个范围的话边权会>m
为了满足所有的儿子
他们对应的区间必须有公共的交集
对于每个区间[L,R]
令Lmax= max{Li}
  Rmin= min{Ri}
若Lmax<=Rmin则有交集
否则没有

#1004:
虽然想到了异或应该按位考虑
但是还是没有做出来
首先要求答案可以按位考虑
假设我们要知道ans的第k位是否为1
就是要知道有多少对ai+aj的第k位为1
若有奇数对,那么第k位为1
否则为0
若ai+aj第k位为1
等价于
(ai+aj)mod 2^(k+1)>=2^k
又因为aimod2^(k+1)+ajmod2^(k+1)<2^(k+2)
所以(ai+aj)mod 2^(k+1)>=2^k
当且仅当
2^k<=aimod2^(k+1)+ajmod2^(k+1)<2^(k+1)
或2^(k+1)+2^k<=aimod2^(k+1)+ajmod2^(k+1)
即满足
2^k-aimod2^(k+1)<=ajmod2^(k+1)<2^(k+1)-aimod2^(k+1)
或2^(k+1)+2^k-aimod2^(k+1)<=ajmod2^(k+1)
对于每个i找有多少个j满足以上的条件
只要用k个线段树维护aimod2^(k+1)即可
但是k个线段树同时开出来的话会mle
所以把所有询问读进来
一位一位的考虑即可
这样就只需要一颗线段树的空间了
利用线段树可以很简单地维护修改与查询
re了半天才发现同时开k颗线段树会mle或re

题目还是做少了,经验不够