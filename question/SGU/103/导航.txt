题目挺长的
读完后迷茫了一会
然后想了想
好像可以贪心地做
弄个堆
堆中元素按当前时间排序
然后每次取时间最小的点去更新其他的点
并把这个点标记一下,表示不能再入堆
复杂度是O(M+logM)的
其实就是dijsktra+heap......
只是更新那一块有点恶心
不过像清楚了还是很简单
就是堆中的每个点记录了当前所在位置
以及在这个位置的时间
每次都用时间去得到当前的状态
状态就是这个灯的颜色和什么时候会变色
若从u到v
那么若当前颜色相同,就直接返回长度
否则若剩下的变色时间不一样,返回小的那个
若一样,先用个变量re累积一下,然后让它们变色
若下次变色时间不一样,返回小的那个
否则再累积一次,让他们变色
若下次时间不一样,返回小的那个
否则就是到不了
因为变化两次的时间之和相等
说明总的周期(tb+tp)是一样的
所以永远是交替的
然后就没了
