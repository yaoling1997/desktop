左偏树的定义:
每个点除左右指针外还有两个属性:键值和距离
键值用来比较节点大小
节点i称为外节点当且仅当节点i的左子树或右子树为空,节点i的距离是节点i到它的后代中,最近外节点所经过的边数。特别的,如果节点i本身是外节点,则它的距离为0,而空节点的距离规定为-1,左偏树的距离为根节点的距离
左偏树的性质:
1:节点的键值小于或等于它的左右子节点的键值
2:节点的左子节点的距离不小于右子节点的距离
左偏树是具有左偏性质的堆有序二叉树
由于性质2,一个节点的距离实际就是这个节点一直沿它的右边到达一个外节点所经过的边数。由此可得性质3
3:dist[i]=dist[right[i]]+1
为满足性质3,故规定空节点距离为-1
4:一颗n个节点的左偏树距离最多为((int)log(n+1))-1
设一颗n个节点的左偏树距离为k,由定理1可知n>=2^(k+1)-1因此k<=((int)log(n+1))-1

引理:
1:若左偏树的距离为一定值，则节点数最少的左偏树是完全二叉树

定理:
1:一颗左偏树的距离为k，则这颗左偏树至少有2^(k+1)-1个节点

左偏树的操作:
左偏树的各种操作都离不开合并
合并两颗左偏树A,B 返回新左偏树C:
若一颗树为空,返回另一颗树
若都非空,设A的根节点键值小于B根节点的键值(否则交换A,B)把A的根节点作为新树C的根节点,合并A的右子树和B
合并后距离会改变，当dist[right[x]]>dist[left[x]]时，需要交换left[x]和right[x]
然后我们需要更新a的距离
插入相当于合并
删除最小节点相当与合并根节点的两颗子树,并返回
构建O(n)
将n个节点放入队列,不断地从队首取出两颗左偏树，合并后放入队尾,当队列中只剩一颗左偏树时,算法结束

删除任意节点:
设q为新树的父亲,p指向这颗新的左偏树,如果删除的是根节点,算法结束,否则要更新父亲
若dist(p)+1=dist(q)则不需要任何调整
若小于,则要不断向上更新,若此时的树为左子树则要交换子树
若大于,使dist(p)+1>dist(q)如果p是左子树,q的距离不变,否则若左子树距离更小，要交换子树,若交换后dist(q)=dist(p)+1,算法结束

BZOJ 2809
