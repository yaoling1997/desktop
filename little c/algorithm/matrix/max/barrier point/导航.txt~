不经过障碍点的极大子矩阵
x:
O(s^2)
s为障碍点个数
以左上角为(1,1),x轴从上到下,y轴从左到右
每次枚举的矩形都是有效子矩形
枚举前加入n*m这个矩形的四个角
注意是按y第一关键字,x第二关键字从小到大排序
一开始上下界为1~n
遇到一个点,先算一下面积
如果遇到一个点的x坐标在l~r内,若x小于枚举点的x则更新下界,否则更新上界
从左到右扫和从右到左扫更新上下界时,任取一个等于
还要判一下和左右边界重合的情况
虽然拍不Wa,但是不能保证是对的(行坐标相同确实有点烦)
感觉论文上说的x相同时的处理方法不对
x1:
由于极大子矩阵的个数不会超过n*m,所以应该有O(n*m)的算法
用悬线法求极大子矩形
有效竖线:除两个端点外,不覆盖任何障碍点的竖直线段
悬线:上端点覆盖了一个障碍点或达到整个矩形上端的有效竖线
如果将一个悬线向左右两个方向尽可能移动所得到的有效子矩形称为这个悬线所对应的子矩形,那么所有悬线所对应的有效子矩形集合一定包含了所有的极大子矩形
尽可能移动是指移动到一个障碍点或着矩形的边界
正确性显然,因为极大子矩形上界一定含有一个障碍点或与矩形边界重合,所以必然有一条悬线扩展后为极大子矩形

BZOJ: 3039
