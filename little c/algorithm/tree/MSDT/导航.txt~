最小树形图(MSDT,minimal directed spanning tree)
也叫最小有向生成树
树形图(arborescence)
O(ve)
貌似还有更快的(O(m+vlog(v))),不过这个应该够用了
这种方法貌似是叫做朱——刘算法(白书上面这么叫的)
算法实现比较简单(最小树形图就是根节点入度为0,其它节点入度均为1,从根可以到达其它所有点的一个玩意)
首先要删自环并从根dfs一遍,看它是否能到达所有点
如果不能到达所有点则没有最小树形图
然后给每个非根节点选择一条权最小的入边,如果n-1条边不够成圈,则显然这些边形成了最小树形图,否则把每个圈缩成一个点,继续上述过程
缩圈之后,圈上所有边的消失了,因此最终答案要累加这些边权之和,但这样做有个问题:假设在算法的某次迭代中,把圈收缩为人工节点v,则在下一次迭代中,给v选择的入弧将与v在圈C中的入弧发生冲突,比如说X在圈中已经有了入弧Y->X,如果收缩之后又选了一个入弧Z->X,必须把弧Y->X从最小树形图中删掉,这等价于把弧Z->X的权值减小了Y->x的权值
起始一开始我不知道为什么这样是对的,但是想一想发现,它每次选的都是最小的边,而且最后肯定是要变成一颗树的(除非它本来就没有最小树形图),从外面向环连一条边不就相当于把环中那条对应的弧切掉吗?
具体实现用邻接矩阵(以前一直以为这东西没什么用,其实还是有点用的
首先初始化邻接矩阵,接着连边,然后dfs判是否有解,然后update所有点(给它们依次找条最小入边,pre[i]存的是i的入边的from是谁,iw[i]就是入边的权了),根节点特殊处理(pre[s]=s,iw[s]=0)(因为根节点入度为0,其余点入度为1)
然后初始化ans,max_cid是用来判环的
找到入边后依次检查(直接无视根结点),cycle判断这个点是否在环上(就是沿着pre一直走,看能不能走回来,如果走了一个环自己却不在环上的话就不用管),如果在环上就把它视为环的代表点(就是用它来代表那个环),removed[]是用来判断这个点还有没有用(如果在环上,由于整个环只要一个代表点,就把其它的点移除,移除就是打标记)
所以弄个v=u然后一直沿着pre[v]走,一路打标记(u就不用打了),由于要删点,所以直接把环上的权值加到答案里去,每枚举到一个点v就用它的入边和出边更新整个被缩的圈(缩完后就变成点了)当然,如果枚举的点i被删或是在环上(在环上表示它还没有来得及打标记),就不用管它了,否则如果这条边不是+oo(+oo表示没有这条边)就用它来更新
w[i][u],更新的时候要注意减去iw[v],因为选择这条边相当于删掉pre[v]->v这条边,所以权值要减去iw[v],i作为入点也要被更新一次(w[u][i]=min(w[u][i],w[v][i]))
如果pre[i]==v还要改成pre[i]=u
然后循环一圈就行了
不过这时要update u了,然后break再继续算,直到没有环为止(最多所有点都被缩了)
最后把没有removed的点的入边权值加上就行了
至于w[i][i]为什么赋为oo,因为总不能自己向自己连边吧
如果不确定根的话就枚举根判所有解就行了

x:
输入一张图
输出以1为根的树形图的权
