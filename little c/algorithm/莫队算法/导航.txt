莫队算法
如果题目可以离线做并且区间[l,r]的值可以由另一个区间[l1,r1]转过来都可以考虑用莫队算法
分为区间上的和树上的,以及带修改的和不带修改的
树上的话之需要把树分块然后跟区间差不多处理就行了
设块大小为B,无修改B= n^0.5,带修改,B= n^(2/3)
设左端点为l,右端点为r
无修改时把询问按l所在块第一关键字,r第二关键字排序
设n,q同级,l在每块内浮动大小不超过n^0.5,共O(n)次
r由于在块内递增,每块是O(n)的,一共n^0.5块
所以总复杂度是n^1.5
到修改的话给询问多加一维t,表示修改时间,每次修改后当前修改时间++
然后将询问按l所在块第一关键字,r所在块第二关键字,t第三关键字排序
n,q还是同级的,由于B= n^(2/3),共n^(1/3)块,设为大块
每块内l的浮动范围不超过n^(2/3),共O(n)次
所以l的复杂度为O(n^(5/3))
每块内r再次分为n^(1/3)块,设为小块,每一小块内的元素个数为n^(1/3),r在小块内浮动范围为n^(2/3),由于大块元素个数为n^(2/3),共n^(1/3)个大块,所以r的复杂度为O(n^(5/3))
由于小块内t递增,为O(n),大块内小块个数为n^(1/3),共n^(1/3)个大块
所以t的复杂度也是O(n^(5/3))
所以总复杂度是O(n^(5/3))
树上的话,先确定块的大小,然后像 王室联邦 那样分,保证了每块之内最远路径长不超过块大小,然后找个lca像区间那样弄就行了
BZOJ: 2038 2120
