x:
有向图强连通分量的kosaraju算法
正着搜一遍，再在转置图(边都是反的)中搜一遍就行了，
这样可以一次搜出一个SCC(strongly connected componenet)
因为第一次深搜时深搜树的根结点肯定是最晚入栈的，图转置后强连通分量上的点依旧可以互达，这样第二次深搜时从树根开始如果仍然可以互达
的话肯定是处于一个强连通分量中的
并且不会搜到其它深搜树上去(它是按SCC拓扑图的逆序搜的)，也就只能一次搞出一个SCC了。
若对于强联通分量i,j,i!=j,i可以到达j
那么在栈中i一定有一个点在j的所有点的上部
因为i可到达j,则j无法到达i(否则是相同的强联通分量)
因为若从k开始dfs,先dfs到j的话
显然栈中i有点在j的上面
若先dfs到i中的点
由于i可以到达j
那么一定是先dfs完j的点后再将i中的某个点加入栈中
又由于原图的拓扑序是转置图的逆拓扑序
所以在转置图中从堆顶开始dfs每次可以dfs出一个SCC
x1:
tarjan(神犇)算法求SCC，用刘汝佳的话来说就是：
它的时间复杂度是线性的，不需要计算图的转置，并且比kosaraju算法常数更小。它是第一个求SCC的线性算法(1972)。
此话是总结了刘汝佳的话后自己说的：
此算法的关键是判断一个点是不是一个SCC中最先被发现的点。
不能被已经确定SCC的点更新，显然。(要是同属于一个SCC的话早就同属于了,不是同一个SCC且low会受到影响，这样肯定是不行的)
当low[o]==pre[o]的时候，也就说明此点乃是这个SCC中第一个被发现的点，可以提取SCC了！
重新连边如果点少的话就邻接矩阵好些，实在不行就邻接表(实在要去掉重边的话就hash或者set搞搞(用set和排序去重都差不多))
每次dfs时就像一条链在延伸
BZOJ: 1051
