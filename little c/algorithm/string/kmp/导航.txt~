x:
kmp算法，返回字串每一次出现的位置。
先搞出失配函数(failure function)
然后匹配就是了，配不上就往回跳
注意搞失配函数时要从模式串的第二位开始
O(m+n)
关键是找到已匹配的串的最大前缀和最大后缀
且最大前缀与最大后缀相等
然后匹配不上就可以跳到最大前缀的末端继续匹配
for example
文本串: ...abaab*.....
模式串     abaaba
           123456
假如模式串最后一位不与*相等
我们已经知道了前5个字符相等
利用已匹配的信息,我们想在合法的情况下尽量把模式串往右移
因为模式串往右移1个,2个,3个都不行
考虑已匹配的串1~5
相等的最大前缀与后缀:ab
那么直接让模式串的前缀ab与文本串的*的前两个字符(ab)对齐,然后接着匹配就行了
LA: 3026
