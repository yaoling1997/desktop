冒泡的两种实现方式
都是从小到大排
x:
每次把最小的元素推到i
x1:
每次把最大的元素推到n-i+1
x2:
跟i位置上的元素比大小，每次使i号位上的元素最小
x3:
用break优化x1的冒泡
设d(x)为x位置后面多少个数字比它小(每次把最小的推到最前面，使前面的d(x)不为0的数的d(x)减少1，为0的不变)
x3中冒泡需要遍历的次数为max(d(x))x= 1 to n
要是有这么一道题问你
给你一个n,k求1~n的排列中有多少个满足x3遍历次数为k的话，就是
k!((k+1)^(n-k)-k^(n-k))
具体怎么证就是首先考虑1的放法
由于1是1~n中排列最小的所以有d(x)= x-1
但d(x)<=k
所以x<=k+1
表明1有k+1种方法
再考虑2~n的排列，同理2也有k+1种放法
把1放到2~n的排列中对原来的d(x)没有影响
总共有n-k个数有k+1种方法
后面k个数就是全排了
所以max(d(x))<=k的个数为k!(k+1)^(n-k)
max(d(x))<=k-1的个数为(k-1)!(k)^(n-k+1)
两式相减得k!(k+1)^(n-k)-(k-1)!(k)^(n-k+1)
化简得k!((k+1)^(n-k)-k^(n-k))

不要看冒泡排序很不起眼,其实它是有很多重要性质的,常被人拿来考
冒泡排序使序列有序的for的次数为序列中每个数字的逆序对数的最大值(每次冒泡使所有有逆序对的数的逆序对减一)
冒泡排序的交换次数为逆序对个数(每次交换使逆序对数减一)
很明显,自己手画
