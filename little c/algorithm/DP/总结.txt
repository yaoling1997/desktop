DP(动态规划)通常用来求解最优化问题。
我们通常按如下4个步骤设计一个动态规划算法：
1：刻画一个最优解的结构特征
2：递归定义最优解的值
3：计算最优解的值
4：利用计算出的信息构造一个最优解(如果只是求最优解的值，此步可省)

DP的两个重要标识：
最优子结构性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。
子问题重叠性质：递归求解时会多次遇到相同子问题

朴素的求解之所以效率低，是因为它反复求解相同的子问题，动态规划对每个子问题只求解一次，并将结果保存下来，方便以后直接调用(以空间换时间)

DP的两种实现方法：
1：带备忘的自顶向下法(俗称记忆化搜索)
递归求解，当求解一个子问题时，先检查是否已保存此问题的解，如果是则直接返回值，否则按通常的方式计算这个子问题
2：自底向上法
首先要定义子问题的规模，使任意子问题的求解只依赖于更小的子问题的求解，所以我们把子问题按规模排序，从小到大求解。当求解一个子问题时，它所依赖的所有子问题已经求解完毕，结果已经保存。
特殊情况下，自顶向下法并未考察到所有可能的子问题
当思考一个动态规划问题时，应该弄清所涉及的子问题及子问题之间的依赖关系

重构解：
开个数组记录当前状态由哪一个状态转移过来，利用所记录的信息构造最优解

最优子结构：
如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有最优子结构性质
发掘一个问题的最优子结构性质：
1：做出一个选择，这次选择会产生一个或多个待解的子问题
2：在第一步选择中假定自己已经知道哪种选择才会得到最优解，你现在并不关心这种选择具体是如何得到的
3：给定可获得最优解的选择后，你确定这次选择会产生哪些问题，以及如何最好地刻画子问题空间。
4：利用“剪切——粘贴”技术证明：构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解，利用反证法证明：假设子问题的解不是最优解，我们可以从原问题的解中剪切掉这些非最优解，把最优解粘贴进去，从而得到原问题的一个更优解，从而产生矛盾
对于不同问题领域，最优子结构的不同往往体现在两个方面：
1：原问题的最优解中涉及多少个子问题
2：确定最优解时使用哪些子问题时，我们需要考察多少种选择。
我们可以用 子问题的总数 和 每个子问题需要考察多少种选择 这两个因素的乘积来粗略分析动态规划算法的运行时间

重叠子问题：
DP应该具备的第二个性质是子问题空间必须足够小，即递归算法会反复地求解相同的子问题，而不是一直生成新的子问题，如果递归算法反复求解相同的子问题，我们称最优化问题具有重叠子问题，与之相对，适合用分治法求解的问题通常在递归的每一步都会生成全新的子问题。DP充分利用了重叠子问题的性质:对每个子问题求解一次，将解存入一个表中，每次查表时间为常量时间
子问题的无关性：两个子问题不共享资源(一个子问题用了，会影响另一个子问题)

UVa: 10891
